{
    "page_content": "# Streaming\u00b6\n\nLangGraph is built with first class support for streaming. There are several different ways to stream back outputs from a graph run\n\n## Streaming graph outputs (`.stream` and `.astream`)\u00b6\n\n`.stream` and `.astream` are sync and async methods for streaming back outputs from a graph run. There are several different modes you can specify when calling these methods (e.g. `graph.stream(..., mode=\"...\")):\n\n  * `\"values\"`: This streams the full value of the state after each step of the graph.\n  * `\"updates\"`: This streams the updates to the state after each step of the graph. If multiple updates are made in the same step (e.g. multiple nodes are run) then those updates are streamed separately.\n  * `\"custom\"`: This streams custom data from inside your graph nodes.\n  * `\"messages\"`: This streams LLM tokens and metadata for the graph node where LLM is invoked.\n  * `\"debug\"`: This streams as much information as possible throughout the execution of the graph.\n\n\n\nYou can also specify multiple streaming modes at the same time by passing them as a list. When you do this, the streamed outputs will be tuples `(stream_mode, data)`. For example:\n[code] \n    graph.stream(..., stream_mode=[\"updates\", \"messages\"])\n    \n[/code]\n[code] \n    ...\n    ('messages', (AIMessageChunk(content='Hi'), {'langgraph_step': 3, 'langgraph_node': 'agent', ...}))\n    ...\n    ('updates', {'agent': {'messages': [AIMessage(content=\"Hi, how can I help you?\")]}})\n    \n[/code]\n\nThe below visualization shows the difference between the `values` and `updates` modes:\n\n## Streaming LLM tokens and events (`.astream_events`)\u00b6\n\nIn addition, you can use the `astream_events` method to stream back events that happen _inside_ nodes. This is useful for streaming tokens of LLM calls.\n\nThis is a standard method on all LangChain objects. This means that as the graph is executed, certain events are emitted along the way and can be seen if you run the graph using `.astream_events`. \n\nAll events have (among other things) `event`, `name`, and `data` fields. What do these mean?\n\n  * `event`: This is the type of event that is being emitted. You can find a detailed table of all callback events and triggers here.\n  * `name`: This is the name of event.\n  * `data`: This is the data associated with the event.\n\n\n\nWhat types of things cause events to be emitted?\n\n  * each node (runnable) emits `on_chain_start` when it starts execution, `on_chain_stream` during the node execution and `on_chain_end` when the node finishes. Node events will have the node name in the event's `name` field\n  * the graph will emit `on_chain_start` in the beginning of the graph execution, `on_chain_stream` after each node execution and `on_chain_end` when the graph finishes. Graph events will have the `LangGraph` in the event's `name` field\n  * Any writes to state channels (i.e. anytime you update the value of one of your state keys) will emit `on_chain_start` and `on_chain_end` events\n\n\n\nAdditionally, any events that are created inside your nodes (LLM events, tool events, manually emitted events, etc.) will also be visible in the output of `.astream_events`.\n\nTo make this more concrete and to see what this looks like, let's see what events are returned when we run a simple graph:\n[code] \n    from langchain_openai import ChatOpenAI\n    from langgraph.graph import StateGraph, MessagesState, START, END\n    \n    model = ChatOpenAI(model=\"gpt-4o-mini\")\n    \n    \n    def call_model(state: MessagesState):\n        response = model.invoke(state['messages'])\n        return {\"messages\": response}\n    \n    workflow = StateGraph(MessagesState)\n    workflow.add_node(call_model)\n    workflow.add_edge(START, \"call_model\")\n    workflow.add_edge(\"call_model\", END)\n    app = workflow.compile()\n    \n    inputs = [{\"role\": \"user\", \"content\": \"hi!\"}]\n    async for event in app.astream_events({\"messages\": inputs}, version=\"v1\"):\n        kind = event[\"event\"]\n        print(f\"{kind}: {event['name']}\")\n    \n[/code]\n\nAPI Reference: ChatOpenAI | StateGraph | START | END\n[code] \n    on_chain_start: LangGraph\n    on_chain_start: __start__\n    on_chain_end: __start__\n    on_chain_start: call_model\n    on_chat_model_start: ChatOpenAI\n    on_chat_model_stream: ChatOpenAI\n    on_chat_model_stream: ChatOpenAI\n    on_chat_model_stream: ChatOpenAI\n    on_chat_model_stream: ChatOpenAI\n    on_chat_model_stream: ChatOpenAI\n    on_chat_model_stream: ChatOpenAI\n    on_chat_model_stream: ChatOpenAI\n    on_chat_model_stream: ChatOpenAI\n    on_chat_model_stream: ChatOpenAI\n    on_chat_model_stream: ChatOpenAI\n    on_chat_model_stream: ChatOpenAI\n    on_chat_model_end: ChatOpenAI\n    on_chain_start: ChannelWrite<call_model,messages>\n    on_chain_end: ChannelWrite<call_model,messages>\n    on_chain_stream: call_model\n    on_chain_end: call_model\n    on_chain_stream: LangGraph\n    on_chain_end: LangGraph\n    \n[/code]\n\nWe start with the overall graph start (`on_chain_start: LangGraph`). We then write to the `__start__` node (this is special node to handle input). We then start the `call_model` node (`on_chain_start: call_model`). We then start the chat model invocation (`on_chat_model_start: ChatOpenAI`), stream back token by token (`on_chat_model_stream: ChatOpenAI`) and then finish the chat model (`on_chat_model_end: ChatOpenAI`). From there, we write the results back to the channel (`ChannelWrite<call_model,messages>`) and then finish the `call_model` node and then the graph as a whole.\n\nThis should hopefully give you a good sense of what events are emitted in a simple graph. But what data do these events contain? Each type of event contains data in a different format. Let's look at what `on_chat_model_stream` events look like. This is an important type of event since it is needed for streaming tokens from an LLM response.\n\nThese events look like:\n[code] \n    {'event': 'on_chat_model_stream',\n     'name': 'ChatOpenAI',\n     'run_id': '3fdbf494-acce-402e-9b50-4eab46403859',\n     'tags': ['seq:step:1'],\n     'metadata': {'langgraph_step': 1,\n      'langgraph_node': 'call_model',\n      'langgraph_triggers': ['start:call_model'],\n      'langgraph_task_idx': 0,\n      'checkpoint_id': '1ef657a0-0f9d-61b8-bffe-0c39e4f9ad6c',\n      'checkpoint_ns': 'call_model',\n      'ls_provider': 'openai',\n      'ls_model_name': 'gpt-4o-mini',\n      'ls_model_type': 'chat',\n      'ls_temperature': 0.7},\n     'data': {'chunk': AIMessageChunk(content='Hello', id='run-3fdbf494-acce-402e-9b50-4eab46403859')},\n     'parent_ids': []}\n    \n[/code]\n\nWe can see that we have the event type and name (which we knew from before).\n\nWe also have a bunch of stuff in metadata. Noticeably, `'langgraph_node': 'call_model',` is some really helpful information which tells us which node this model was invoked inside of.\n\nFinally, `data` is a really important field. This contains the actual data for this event! Which in this case is an AIMessageChunk. This contains the `content` for the message, as well as an `id`. This is the ID of the overall AIMessage (not just this chunk) and is super helpful - it helps us track which chunks are part of the same message (so we can show them together in the UI).\n\nThis information contains all that is needed for creating a UI for streaming LLM tokens. You can see a guide for that here.\n\nASYNC IN PYTHON<=3.10\n\nYou may fail to see events being emitted from inside a node when using `.astream_events` in Python <= 3.10. If you're using a Langchain RunnableLambda, a RunnableGenerator, or Tool asynchronously inside your node, you will have to propagate callbacks to these objects manually. This is because LangChain cannot automatically propagate callbacks to child objects in this case.\n\n## LangGraph Platform\u00b6\n\nStreaming is critical for making LLM applications feel responsive to end users. When creating a streaming run, the streaming mode determines what data is streamed back to the API client. LangGraph Platform supports five streaming modes:\n\n  * `values`: Stream the full state of the graph after each super-step is executed. See the how-to guide for streaming values.\n  * `messages-tuple`: Stream LLM tokens for any messages generated inside a node. This mode is primarily meant for powering chat applications. See the how-to guide for streaming messages.\n  * `updates`: Streams updates to the state of the graph after each node is executed. See the how-to guide for streaming updates.\n  * `events`: Stream all events (including the state of the graph) that occur during graph execution. See the how-to guide for streaming events. This can be used to do token-by-token streaming for LLMs.\n  * `debug`: Stream debug events throughout graph execution. See the how-to guide for streaming debug events.\n\n\n\nYou can also specify multiple streaming modes at the same time. See the how-to guide for configuring multiple streaming modes at the same time.\n\nSee the API reference for how to create streaming runs.\n\nStreaming modes `values`, `updates`, `messages-tuple` and `debug` are very similar to modes available in the LangGraph library - for a deeper conceptual explanation of those, you can see the previous section.\n\nStreaming mode `events` is the same as using `.astream_events` in the LangGraph library - for a deeper conceptual explanation of this, you can see the previous section.\n\nAll events emitted have two attributes:\n\n  * `event`: This is the name of the event\n  * `data`: This is data associated with the event\n\n\n\n## Comments\n",
    "metadata": {
        "url": "https://langchain-ai.github.io/langgraph/concepts/streaming/",
        "title": "Streaming",
        "description": "Build language agents as graphs",
        "keywords": "No keywords"
    }
}