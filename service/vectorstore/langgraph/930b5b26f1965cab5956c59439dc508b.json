{
    "page_content": "# Checkpointers\u00b6\n\n##  `` `CheckpointMetadata` \u00b6\n\nBases: `TypedDict`\n\nMetadata associated with a checkpoint.\n\n###  `` `source: Literal['input', 'loop', 'update', 'fork']` `instance-attribute` \u00b6\n\nThe source of the checkpoint.\n\n  * \"input\": The checkpoint was created from an input to invoke/stream/batch.\n  * \"loop\": The checkpoint was created from inside the pregel loop.\n  * \"update\": The checkpoint was created from a manual state update.\n  * \"fork\": The checkpoint was created as a copy of another checkpoint.\n\n\n\n###  `` `step: int` `instance-attribute` \u00b6\n\nThe step number of the checkpoint.\n\n-1 for the first \"input\" checkpoint. 0 for the first \"loop\" checkpoint. ... for the nth checkpoint afterwards.\n\n###  `` `writes: dict[str, Any]` `instance-attribute` \u00b6\n\nThe writes that were made between the previous checkpoint and this one.\n\nMapping from node name to writes emitted by that node.\n\n###  `` `parents: dict[str, str]` `instance-attribute` \u00b6\n\nThe IDs of the parent checkpoints.\n\nMapping from checkpoint namespace to checkpoint ID.\n\n##  `` `Checkpoint` \u00b6\n\nBases: `TypedDict`\n\nState snapshot at a given point in time.\n\n###  `` `v: int` `instance-attribute` \u00b6\n\nThe version of the checkpoint format. Currently 1.\n\n###  `` `id: str` `instance-attribute` \u00b6\n\nThe ID of the checkpoint. This is both unique and monotonically increasing, so can be used for sorting checkpoints from first to last.\n\n###  `` `ts: str` `instance-attribute` \u00b6\n\nThe timestamp of the checkpoint in ISO 8601 format.\n\n###  `` `channel_values: dict[str, Any]` `instance-attribute` \u00b6\n\nThe values of the channels at the time of the checkpoint. Mapping from channel name to deserialized channel snapshot value.\n\n###  `` `channel_versions: ChannelVersions` `instance-attribute` \u00b6\n\nThe versions of the channels at the time of the checkpoint. The keys are channel names and the values are monotonically increasing version strings for each channel.\n\n###  `` `versions_seen: dict[str, ChannelVersions]` `instance-attribute` \u00b6\n\nMap from node ID to map from channel name to version seen. This keeps track of the versions of the channels that each node has seen. Used to determine which nodes to execute next.\n\n###  `` `pending_sends: List[SendProtocol]` `instance-attribute` \u00b6\n\nList of inputs pushed to nodes but not yet processed. Cleared by the next checkpoint.\n\n##  `` `BaseCheckpointSaver` \u00b6\n\nBases: `Generic[V]`\n\nBase class for creating a graph checkpointer.\n\nCheckpointers allow LangGraph agents to persist their state within and across multiple interactions.\n\nAttributes:\n\n  * **`serde`** (`SerializerProtocol`) \u2013 \n\nSerializer for encoding/decoding checkpoints.\n\n\nNote\n\nWhen creating a custom checkpoint saver, consider implementing async versions to avoid blocking the main thread.\n\n###  `` `config_specs: list[ConfigurableFieldSpec]` `property` \u00b6\n\nDefine the configuration options for the checkpoint saver.\n\nReturns:\n\n  * `list[ConfigurableFieldSpec]` \u2013 \n\nlist[ConfigurableFieldSpec]: List of configuration field specs.\n\n\n\n\n###  `` `get(config: RunnableConfig) -> Optional[Checkpoint]` \u00b6\n\nFetch a checkpoint using the given configuration.\n\nParameters:\n\n  * **`config`** (`RunnableConfig`) \u2013 \n\nConfiguration specifying which checkpoint to retrieve.\n\n\n\n\nReturns:\n\n  * `Optional[Checkpoint]` \u2013 \n\nOptional[Checkpoint]: The requested checkpoint, or None if not found.\n\n\n\n\n###  `` `get_tuple(config: RunnableConfig) -> Optional[CheckpointTuple]` \u00b6\n\nFetch a checkpoint tuple using the given configuration.\n\nParameters:\n\n  * **`config`** (`RunnableConfig`) \u2013 \n\nConfiguration specifying which checkpoint to retrieve.\n\n\n\n\nReturns:\n\n  * `Optional[CheckpointTuple]` \u2013 \n\nOptional[CheckpointTuple]: The requested checkpoint tuple, or None if not found.\n\n\n\n\nRaises:\n\n  * `NotImplementedError` \u2013 \n\nImplement this method in your custom checkpoint saver.\n\n\n\n\n###  `` `list(config: Optional[RunnableConfig], *, filter: Optional[Dict[str, Any]] = None, before: Optional[RunnableConfig] = None, limit: Optional[int] = None) -> Iterator[CheckpointTuple]` \u00b6\n\nList checkpoints that match the given criteria.\n\nParameters:\n\n  * **`config`** (`Optional[RunnableConfig]`) \u2013 \n\nBase configuration for filtering checkpoints.\n\n  * **`filter`** (`Optional[Dict[str, Any]]`, default: `None` ) \u2013 \n\nAdditional filtering criteria.\n\n  * **`before`** (`Optional[RunnableConfig]`, default: `None` ) \u2013 \n\nList checkpoints created before this configuration.\n\n  * **`limit`** (`Optional[int]`, default: `None` ) \u2013 \n\nMaximum number of checkpoints to return.\n\n\n\n\nReturns:\n\n  * `Iterator[CheckpointTuple]` \u2013 \n\nIterator[CheckpointTuple]: Iterator of matching checkpoint tuples.\n\n\n\n\nRaises:\n\n  * `NotImplementedError` \u2013 \n\nImplement this method in your custom checkpoint saver.\n\n\n\n\n###  `` `put(config: RunnableConfig, checkpoint: Checkpoint, metadata: CheckpointMetadata, new_versions: ChannelVersions) -> RunnableConfig` \u00b6\n\nStore a checkpoint with its configuration and metadata.\n\nParameters:\n\n  * **`config`** (`RunnableConfig`) \u2013 \n\nConfiguration for the checkpoint.\n\n  * **`checkpoint`** (`Checkpoint`) \u2013 \n\nThe checkpoint to store.\n\n  * **`metadata`** (`CheckpointMetadata`) \u2013 \n\nAdditional metadata for the checkpoint.\n\n  * **`new_versions`** (`ChannelVersions`) \u2013 \n\nNew channel versions as of this write.\n\n\n\n\nReturns:\n\n  * **`RunnableConfig`** ( `RunnableConfig` ) \u2013 \n\nUpdated configuration after storing the checkpoint.\n\n\n\n\nRaises:\n\n  * `NotImplementedError` \u2013 \n\nImplement this method in your custom checkpoint saver.\n\n\n\n\n###  `` `put_writes(config: RunnableConfig, writes: Sequence[Tuple[str, Any]], task_id: str, task_path: str = '') -> None` \u00b6\n\nStore intermediate writes linked to a checkpoint.\n\nParameters:\n\n  * **`config`** (`RunnableConfig`) \u2013 \n\nConfiguration of the related checkpoint.\n\n  * **`writes`** (`List[Tuple[str, Any]]`) \u2013 \n\nList of writes to store.\n\n  * **`task_id`** (`str`) \u2013 \n\nIdentifier for the task creating the writes.\n\n  * **`task_path`** (`str`, default: `''` ) \u2013 \n\nPath of the task creating the writes.\n\n\n\n\nRaises:\n\n  * `NotImplementedError` \u2013 \n\nImplement this method in your custom checkpoint saver.\n\n\n\n\n###  `` `aget(config: RunnableConfig) -> Optional[Checkpoint]` `async` \u00b6\n\nAsynchronously fetch a checkpoint using the given configuration.\n\nParameters:\n\n  * **`config`** (`RunnableConfig`) \u2013 \n\nConfiguration specifying which checkpoint to retrieve.\n\n\n\n\nReturns:\n\n  * `Optional[Checkpoint]` \u2013 \n\nOptional[Checkpoint]: The requested checkpoint, or None if not found.\n\n\n\n\n###  `` `aget_tuple(config: RunnableConfig) -> Optional[CheckpointTuple]` `async` \u00b6\n\nAsynchronously fetch a checkpoint tuple using the given configuration.\n\nParameters:\n\n  * **`config`** (`RunnableConfig`) \u2013 \n\nConfiguration specifying which checkpoint to retrieve.\n\n\n\n\nReturns:\n\n  * `Optional[CheckpointTuple]` \u2013 \n\nOptional[CheckpointTuple]: The requested checkpoint tuple, or None if not found.\n\n\n\n\nRaises:\n\n  * `NotImplementedError` \u2013 \n\nImplement this method in your custom checkpoint saver.\n\n\n\n\n###  `` `alist(config: Optional[RunnableConfig], *, filter: Optional[Dict[str, Any]] = None, before: Optional[RunnableConfig] = None, limit: Optional[int] = None) -> AsyncIterator[CheckpointTuple]` `async` \u00b6\n\nAsynchronously list checkpoints that match the given criteria.\n\nParameters:\n\n  * **`config`** (`Optional[RunnableConfig]`) \u2013 \n\nBase configuration for filtering checkpoints.\n\n  * **`filter`** (`Optional[Dict[str, Any]]`, default: `None` ) \u2013 \n\nAdditional filtering criteria for metadata.\n\n  * **`before`** (`Optional[RunnableConfig]`, default: `None` ) \u2013 \n\nList checkpoints created before this configuration.\n\n  * **`limit`** (`Optional[int]`, default: `None` ) \u2013 \n\nMaximum number of checkpoints to return.\n\n\n\n\nReturns:\n\n  * `AsyncIterator[CheckpointTuple]` \u2013 \n\nAsyncIterator[CheckpointTuple]: Async iterator of matching checkpoint tuples.\n\n\n\n\nRaises:\n\n  * `NotImplementedError` \u2013 \n\nImplement this method in your custom checkpoint saver.\n\n\n\n\n###  `` `aput(config: RunnableConfig, checkpoint: Checkpoint, metadata: CheckpointMetadata, new_versions: ChannelVersions) -> RunnableConfig` `async` \u00b6\n\nAsynchronously store a checkpoint with its configuration and metadata.\n\nParameters:\n\n  * **`config`** (`RunnableConfig`) \u2013 \n\nConfiguration for the checkpoint.\n\n  * **`checkpoint`** (`Checkpoint`) \u2013 \n\nThe checkpoint to store.\n\n  * **`metadata`** (`CheckpointMetadata`) \u2013 \n\nAdditional metadata for the checkpoint.\n\n  * **`new_versions`** (`ChannelVersions`) \u2013 \n\nNew channel versions as of this write.\n\n\n\n\nReturns:\n\n  * **`RunnableConfig`** ( `RunnableConfig` ) \u2013 \n\nUpdated configuration after storing the checkpoint.\n\n\n\n\nRaises:\n\n  * `NotImplementedError` \u2013 \n\nImplement this method in your custom checkpoint saver.\n\n\n\n\n###  `` `aput_writes(config: RunnableConfig, writes: Sequence[Tuple[str, Any]], task_id: str, task_path: str = '') -> None` `async` \u00b6\n\nAsynchronously store intermediate writes linked to a checkpoint.\n\nParameters:\n\n  * **`config`** (`RunnableConfig`) \u2013 \n\nConfiguration of the related checkpoint.\n\n  * **`writes`** (`List[Tuple[str, Any]]`) \u2013 \n\nList of writes to store.\n\n  * **`task_id`** (`str`) \u2013 \n\nIdentifier for the task creating the writes.\n\n  * **`task_path`** (`str`, default: `''` ) \u2013 \n\nPath of the task creating the writes.\n\n\n\n\nRaises:\n\n  * `NotImplementedError` \u2013 \n\nImplement this method in your custom checkpoint saver.\n\n\n\n\n###  `` `get_next_version(current: Optional[V], channel: ChannelProtocol) -> V` \u00b6\n\nGenerate the next version ID for a channel.\n\nDefault is to use integer versions, incrementing by 1. If you override, you can use str/int/float versions, as long as they are monotonically increasing.\n\nParameters:\n\n  * **`current`** (`Optional[V]`) \u2013 \n\nThe current version identifier (int, float, or str).\n\n  * **`channel`** (`BaseChannel`) \u2013 \n\nThe channel being versioned.\n\n\n\n\nReturns:\n\n  * **`V`** ( `V` ) \u2013 \n\nThe next version identifier, which must be increasing.\n\n\n\n\n##  `` `create_checkpoint(checkpoint: Checkpoint, channels: Optional[Mapping[str, ChannelProtocol]], step: int, *, id: Optional[str] = None) -> Checkpoint` \u00b6\n\nCreate a checkpoint for the given channels.\n\n##  `` `SerializerProtocol` \u00b6\n\nBases: `Protocol`\n\nProtocol for serialization and deserialization of objects.\n\n  * `dumps`: Serialize an object to bytes.\n  * `dumps_typed`: Serialize an object to a tuple (type, bytes).\n  * `loads`: Deserialize an object from bytes.\n  * `loads_typed`: Deserialize an object from a tuple (type, bytes).\n\n\n\nValid implementations include the `pickle`, `json` and `orjson` modules.\n\n##  `` `JsonPlusSerializer` \u00b6\n\nBases: `SerializerProtocol`\n\n##  `` `InMemorySaver` \u00b6\n\nBases: `BaseCheckpointSaver[str]`, `AbstractContextManager`, `AbstractAsyncContextManager`\n\nAn in-memory checkpoint saver.\n\nThis checkpoint saver stores checkpoints in memory using a defaultdict.\n\nNote\n\nOnly use `InMemorySaver` for debugging or testing purposes. For production use cases we recommend installing langgraph-checkpoint-postgres and using `PostgresSaver` / `AsyncPostgresSaver`.\n\nParameters:\n\n  * **`serde`** (`Optional[SerializerProtocol]`, default: `None` ) \u2013 \n\nThe serializer to use for serializing and deserializing checkpoints. Defaults to None.\n\n\n\n\nExamples:\n[code] \n        import asyncio\n    \n        from langgraph.checkpoint.memory import InMemorySaver\n        from langgraph.graph import StateGraph\n    \n        builder = StateGraph(int)\n        builder.add_node(\"add_one\", lambda x: x + 1)\n        builder.set_entry_point(\"add_one\")\n        builder.set_finish_point(\"add_one\")\n    \n        memory = InMemorySaver()\n        graph = builder.compile(checkpointer=memory)\n        coro = graph.ainvoke(1, {\"configurable\": {\"thread_id\": \"thread-1\"}})\n        asyncio.run(coro)  # Output: 2\n    \n[/code]\n\n###  `` `config_specs: list[ConfigurableFieldSpec]` `property` \u00b6\n\nDefine the configuration options for the checkpoint saver.\n\nReturns:\n\n  * `list[ConfigurableFieldSpec]` \u2013 \n\nlist[ConfigurableFieldSpec]: List of configuration field specs.\n\n\n\n\n###  `` `get(config: RunnableConfig) -> Optional[Checkpoint]` \u00b6\n\nFetch a checkpoint using the given configuration.\n\nParameters:\n\n  * **`config`** (`RunnableConfig`) \u2013 \n\nConfiguration specifying which checkpoint to retrieve.\n\n\n\n\nReturns:\n\n  * `Optional[Checkpoint]` \u2013 \n\nOptional[Checkpoint]: The requested checkpoint, or None if not found.\n\n\n\n\n###  `` `aget(config: RunnableConfig) -> Optional[Checkpoint]` `async` \u00b6\n\nAsynchronously fetch a checkpoint using the given configuration.\n\nParameters:\n\n  * **`config`** (`RunnableConfig`) \u2013 \n\nConfiguration specifying which checkpoint to retrieve.\n\n\n\n\nReturns:\n\n  * `Optional[Checkpoint]` \u2013 \n\nOptional[Checkpoint]: The requested checkpoint, or None if not found.\n\n\n\n\n###  `` `get_tuple(config: RunnableConfig) -> Optional[CheckpointTuple]` \u00b6\n\nGet a checkpoint tuple from the in-memory storage.\n\nThis method retrieves a checkpoint tuple from the in-memory storage based on the provided config. If the config contains a \"checkpoint_id\" key, the checkpoint with the matching thread ID and timestamp is retrieved. Otherwise, the latest checkpoint for the given thread ID is retrieved.\n\nParameters:\n\n  * **`config`** (`RunnableConfig`) \u2013 \n\nThe config to use for retrieving the checkpoint.\n\n\n\n\nReturns:\n\n  * `Optional[CheckpointTuple]` \u2013 \n\nOptional[CheckpointTuple]: The retrieved checkpoint tuple, or None if no matching checkpoint was found.\n\n\n\n\n###  `` `list(config: Optional[RunnableConfig], *, filter: Optional[dict[str, Any]] = None, before: Optional[RunnableConfig] = None, limit: Optional[int] = None) -> Iterator[CheckpointTuple]` \u00b6\n\nList checkpoints from the in-memory storage.\n\nThis method retrieves a list of checkpoint tuples from the in-memory storage based on the provided criteria.\n\nParameters:\n\n  * **`config`** (`Optional[RunnableConfig]`) \u2013 \n\nBase configuration for filtering checkpoints.\n\n  * **`filter`** (`Optional[Dict[str, Any]]`, default: `None` ) \u2013 \n\nAdditional filtering criteria for metadata.\n\n  * **`before`** (`Optional[RunnableConfig]`, default: `None` ) \u2013 \n\nList checkpoints created before this configuration.\n\n  * **`limit`** (`Optional[int]`, default: `None` ) \u2013 \n\nMaximum number of checkpoints to return.\n\n\n\n\nYields:\n\n  * `CheckpointTuple` \u2013 \n\nIterator[CheckpointTuple]: An iterator of matching checkpoint tuples.\n\n\n\n\n###  `` `put(config: RunnableConfig, checkpoint: Checkpoint, metadata: CheckpointMetadata, new_versions: ChannelVersions) -> RunnableConfig` \u00b6\n\nSave a checkpoint to the in-memory storage.\n\nThis method saves a checkpoint to the in-memory storage. The checkpoint is associated with the provided config.\n\nParameters:\n\n  * **`config`** (`RunnableConfig`) \u2013 \n\nThe config to associate with the checkpoint.\n\n  * **`checkpoint`** (`Checkpoint`) \u2013 \n\nThe checkpoint to save.\n\n  * **`metadata`** (`CheckpointMetadata`) \u2013 \n\nAdditional metadata to save with the checkpoint.\n\n  * **`new_versions`** (`dict`) \u2013 \n\nNew versions as of this write\n\n\n\n\nReturns:\n\n  * **`RunnableConfig`** ( `RunnableConfig` ) \u2013 \n\nThe updated config containing the saved checkpoint's timestamp.\n\n\n\n\n###  `` `put_writes(config: RunnableConfig, writes: Sequence[tuple[str, Any]], task_id: str, task_path: str = '') -> None` \u00b6\n\nSave a list of writes to the in-memory storage.\n\nThis method saves a list of writes to the in-memory storage. The writes are associated with the provided config.\n\nParameters:\n\n  * **`config`** (`RunnableConfig`) \u2013 \n\nThe config to associate with the writes.\n\n  * **`writes`** (`list[tuple[str, Any]]`) \u2013 \n\nThe writes to save.\n\n  * **`task_id`** (`str`) \u2013 \n\nIdentifier for the task creating the writes.\n\n  * **`task_path`** (`str`, default: `''` ) \u2013 \n\nPath of the task creating the writes.\n\n\n\n\nReturns:\n\n  * **`RunnableConfig`** ( `None` ) \u2013 \n\nThe updated config containing the saved writes' timestamp.\n\n\n\n\n###  `` `aget_tuple(config: RunnableConfig) -> Optional[CheckpointTuple]` `async` \u00b6\n\nAsynchronous version of get_tuple.\n\nThis method is an asynchronous wrapper around get_tuple that runs the synchronous method in a separate thread using asyncio.\n\nParameters:\n\n  * **`config`** (`RunnableConfig`) \u2013 \n\nThe config to use for retrieving the checkpoint.\n\n\n\n\nReturns:\n\n  * `Optional[CheckpointTuple]` \u2013 \n\nOptional[CheckpointTuple]: The retrieved checkpoint tuple, or None if no matching checkpoint was found.\n\n\n\n\n###  `` `alist(config: Optional[RunnableConfig], *, filter: Optional[dict[str, Any]] = None, before: Optional[RunnableConfig] = None, limit: Optional[int] = None) -> AsyncIterator[CheckpointTuple]` `async` \u00b6\n\nAsynchronous version of list.\n\nThis method is an asynchronous wrapper around list that runs the synchronous method in a separate thread using asyncio.\n\nParameters:\n\n  * **`config`** (`RunnableConfig`) \u2013 \n\nThe config to use for listing the checkpoints.\n\n\n\n\nYields:\n\n  * `AsyncIterator[CheckpointTuple]` \u2013 \n\nAsyncIterator[CheckpointTuple]: An asynchronous iterator of checkpoint tuples.\n\n\n\n\n###  `` `aput(config: RunnableConfig, checkpoint: Checkpoint, metadata: CheckpointMetadata, new_versions: ChannelVersions) -> RunnableConfig` `async` \u00b6\n\nAsynchronous version of put.\n\nParameters:\n\n  * **`config`** (`RunnableConfig`) \u2013 \n\nThe config to associate with the checkpoint.\n\n  * **`checkpoint`** (`Checkpoint`) \u2013 \n\nThe checkpoint to save.\n\n  * **`metadata`** (`CheckpointMetadata`) \u2013 \n\nAdditional metadata to save with the checkpoint.\n\n  * **`new_versions`** (`dict`) \u2013 \n\nNew versions as of this write\n\n\n\n\nReturns:\n\n  * **`RunnableConfig`** ( `RunnableConfig` ) \u2013 \n\nThe updated config containing the saved checkpoint's timestamp.\n\n\n\n\n###  `` `aput_writes(config: RunnableConfig, writes: Sequence[tuple[str, Any]], task_id: str, task_path: str = '') -> None` `async` \u00b6\n\nAsynchronous version of put_writes.\n\nThis method is an asynchronous wrapper around put_writes that runs the synchronous method in a separate thread using asyncio.\n\nParameters:\n\n  * **`config`** (`RunnableConfig`) \u2013 \n\nThe config to associate with the writes.\n\n  * **`writes`** (`List[Tuple[str, Any]]`) \u2013 \n\nThe writes to save, each as a (channel, value) pair.\n\n  * **`task_id`** (`str`) \u2013 \n\nIdentifier for the task creating the writes.\n\n  * **`task_path`** (`str`, default: `''` ) \u2013 \n\nPath of the task creating the writes.\n\n\n\n\nReturns:\n\n  * `None` \u2013 \n\nNone\n\n\n\n\n##  `` `PersistentDict` \u00b6\n\nBases: `defaultdict`\n\nPersistent dictionary with an API compatible with shelve and anydbm.\n\nThe dict is kept in memory, so the dictionary operations run as fast as a regular dictionary.\n\nWrite to disk is delayed until close or sync (similar to gdbm's fast mode).\n\nInput file format is automatically discovered. Output file format is selectable between pickle, json, and csv. All three serialization formats are backed by fast C implementations.\n\nAdapted from https://code.activestate.com/recipes/576642-persistent-dict-with-multiple-standard-file-format/\n\n###  `` `sync() -> None` \u00b6\n\nWrite dict to disk\n\n##  `` `SqliteSaver` \u00b6\n\nBases: `BaseCheckpointSaver[str]`\n\nA checkpoint saver that stores checkpoints in a SQLite database.\n\nNote\n\nThis class is meant for lightweight, synchronous use cases (demos and small projects) and does not scale to multiple threads. For a similar sqlite saver with `async` support, consider using AsyncSqliteSaver.\n\nParameters:\n\n  * **`conn`** (`Connection`) \u2013 \n\nThe SQLite database connection.\n\n  * **`serde`** (`Optional[SerializerProtocol]`, default: `None` ) \u2013 \n\nThe serializer to use for serializing and deserializing checkpoints. Defaults to JsonPlusSerializerCompat.\n\n\n\n\nExamples:\n[code] \n    >>> import sqlite3\n    >>> from langgraph.checkpoint.sqlite import SqliteSaver\n    >>> from langgraph.graph import StateGraph\n    >>>\n    >>> builder = StateGraph(int)\n    >>> builder.add_node(\"add_one\", lambda x: x + 1)\n    >>> builder.set_entry_point(\"add_one\")\n    >>> builder.set_finish_point(\"add_one\")\n    >>> conn = sqlite3.connect(\"checkpoints.sqlite\")\n    >>> memory = SqliteSaver(conn)\n    >>> graph = builder.compile(checkpointer=memory)\n    >>> config = {\"configurable\": {\"thread_id\": \"1\"}}\n    >>> graph.get_state(config)\n    >>> result = graph.invoke(3, config)\n    >>> graph.get_state(config)\n    StateSnapshot(values=4, next=(), config={'configurable': {'thread_id': '1', 'checkpoint_ns': '', 'checkpoint_id': '0c62ca34-ac19-445d-bbb0-5b4984975b2a'}}, parent_config=None)\n    \n[/code]\n\n###  `` `config_specs: list[ConfigurableFieldSpec]` `property` \u00b6\n\nDefine the configuration options for the checkpoint saver.\n\nReturns:\n\n  * `list[ConfigurableFieldSpec]` \u2013 \n\nlist[ConfigurableFieldSpec]: List of configuration field specs.\n\n\n\n\n###  `` `get(config: RunnableConfig) -> Optional[Checkpoint]` \u00b6\n\nFetch a checkpoint using the given configuration.\n\nParameters:\n\n  * **`config`** (`RunnableConfig`) \u2013 \n\nConfiguration specifying which checkpoint to retrieve.\n\n\n\n\nReturns:\n\n  * `Optional[Checkpoint]` \u2013 \n\nOptional[Checkpoint]: The requested checkpoint, or None if not found.\n\n\n\n\n###  `` `aget(config: RunnableConfig) -> Optional[Checkpoint]` `async` \u00b6\n\nAsynchronously fetch a checkpoint using the given configuration.\n\nParameters:\n\n  * **`config`** (`RunnableConfig`) \u2013 \n\nConfiguration specifying which checkpoint to retrieve.\n\n\n\n\nReturns:\n\n  * `Optional[Checkpoint]` \u2013 \n\nOptional[Checkpoint]: The requested checkpoint, or None if not found.\n\n\n\n\n###  `` `aput_writes(config: RunnableConfig, writes: Sequence[Tuple[str, Any]], task_id: str, task_path: str = '') -> None` `async` \u00b6\n\nAsynchronously store intermediate writes linked to a checkpoint.\n\nParameters:\n\n  * **`config`** (`RunnableConfig`) \u2013 \n\nConfiguration of the related checkpoint.\n\n  * **`writes`** (`List[Tuple[str, Any]]`) \u2013 \n\nList of writes to store.\n\n  * **`task_id`** (`str`) \u2013 \n\nIdentifier for the task creating the writes.\n\n  * **`task_path`** (`str`, default: `''` ) \u2013 \n\nPath of the task creating the writes.\n\n\n\n\nRaises:\n\n  * `NotImplementedError` \u2013 \n\nImplement this method in your custom checkpoint saver.\n\n\n\n\n###  `` `from_conn_string(conn_string: str) -> Iterator[SqliteSaver]` `classmethod` \u00b6\n\nCreate a new SqliteSaver instance from a connection string.\n\nParameters:\n\n  * **`conn_string`** (`str`) \u2013 \n\nThe SQLite connection string.\n\n\n\n\nYields:\n\n  * **`SqliteSaver`** ( `SqliteSaver` ) \u2013 \n\nA new SqliteSaver instance.\n\n\n\n\nExamples:\n[code] \n    In memory:\n    \n        with SqliteSaver.from_conn_string(\":memory:\") as memory:\n            ...\n    \n    To disk:\n    \n        with SqliteSaver.from_conn_string(\"checkpoints.sqlite\") as memory:\n            ...\n    \n[/code]\n\n###  `` `setup() -> None` \u00b6\n\nSet up the checkpoint database.\n\nThis method creates the necessary tables in the SQLite database if they don't already exist. It is called automatically when needed and should not be called directly by the user.\n\n###  `` `cursor(transaction: bool = True) -> Iterator[sqlite3.Cursor]` \u00b6\n\nGet a cursor for the SQLite database.\n\nThis method returns a cursor for the SQLite database. It is used internally by the SqliteSaver and should not be called directly by the user.\n\nParameters:\n\n  * **`transaction`** (`bool`, default: `True` ) \u2013 \n\nWhether to commit the transaction when the cursor is closed. Defaults to True.\n\n\n\n\nYields:\n\n  * `Cursor` \u2013 \n\nsqlite3.Cursor: A cursor for the SQLite database.\n\n\n\n\n###  `` `get_tuple(config: RunnableConfig) -> Optional[CheckpointTuple]` \u00b6\n\nGet a checkpoint tuple from the database.\n\nThis method retrieves a checkpoint tuple from the SQLite database based on the provided config. If the config contains a \"checkpoint_id\" key, the checkpoint with the matching thread ID and checkpoint ID is retrieved. Otherwise, the latest checkpoint for the given thread ID is retrieved.\n\nParameters:\n\n  * **`config`** (`RunnableConfig`) \u2013 \n\nThe config to use for retrieving the checkpoint.\n\n\n\n\nReturns:\n\n  * `Optional[CheckpointTuple]` \u2013 \n\nOptional[CheckpointTuple]: The retrieved checkpoint tuple, or None if no matching checkpoint was found.\n\n\n\n\nExamples:\n[code] \n    Basic:\n    >>> config = {\"configurable\": {\"thread_id\": \"1\"}}\n    >>> checkpoint_tuple = memory.get_tuple(config)\n    >>> print(checkpoint_tuple)\n    CheckpointTuple(...)\n    \n    With checkpoint ID:\n    \n    >>> config = {\n    ...    \"configurable\": {\n    ...        \"thread_id\": \"1\",\n    ...        \"checkpoint_ns\": \"\",\n    ...        \"checkpoint_id\": \"1ef4f797-8335-6428-8001-8a1503f9b875\",\n    ...    }\n    ... }\n    >>> checkpoint_tuple = memory.get_tuple(config)\n    >>> print(checkpoint_tuple)\n    CheckpointTuple(...)\n    \n[/code]\n\n###  `` `list(config: Optional[RunnableConfig], *, filter: Optional[Dict[str, Any]] = None, before: Optional[RunnableConfig] = None, limit: Optional[int] = None) -> Iterator[CheckpointTuple]` \u00b6\n\nList checkpoints from the database.\n\nThis method retrieves a list of checkpoint tuples from the SQLite database based on the provided config. The checkpoints are ordered by checkpoint ID in descending order (newest first).\n\nParameters:\n\n  * **`config`** (`RunnableConfig`) \u2013 \n\nThe config to use for listing the checkpoints.\n\n  * **`filter`** (`Optional[Dict[str, Any]]`, default: `None` ) \u2013 \n\nAdditional filtering criteria for metadata. Defaults to None.\n\n  * **`before`** (`Optional[RunnableConfig]`, default: `None` ) \u2013 \n\nIf provided, only checkpoints before the specified checkpoint ID are returned. Defaults to None.\n\n  * **`limit`** (`Optional[int]`, default: `None` ) \u2013 \n\nThe maximum number of checkpoints to return. Defaults to None.\n\n\n\n\nYields:\n\n  * `CheckpointTuple` \u2013 \n\nIterator[CheckpointTuple]: An iterator of checkpoint tuples.\n\n\n\n\nExamples:\n[code] \n    >>> from langgraph.checkpoint.sqlite import SqliteSaver\n    >>> with SqliteSaver.from_conn_string(\":memory:\") as memory:\n    ... # Run a graph, then list the checkpoints\n    >>>     config = {\"configurable\": {\"thread_id\": \"1\"}}\n    >>>     checkpoints = list(memory.list(config, limit=2))\n    >>> print(checkpoints)\n    [CheckpointTuple(...), CheckpointTuple(...)]\n    \n[/code]\n[code] \n    >>> config = {\"configurable\": {\"thread_id\": \"1\"}}\n    >>> before = {\"configurable\": {\"checkpoint_id\": \"1ef4f797-8335-6428-8001-8a1503f9b875\"}}\n    >>> with SqliteSaver.from_conn_string(\":memory:\") as memory:\n    ... # Run a graph, then list the checkpoints\n    >>>     checkpoints = list(memory.list(config, before=before))\n    >>> print(checkpoints)\n    [CheckpointTuple(...), ...]\n    \n[/code]\n\n###  `` `put(config: RunnableConfig, checkpoint: Checkpoint, metadata: CheckpointMetadata, new_versions: ChannelVersions) -> RunnableConfig` \u00b6\n\nSave a checkpoint to the database.\n\nThis method saves a checkpoint to the SQLite database. The checkpoint is associated with the provided config and its parent config (if any).\n\nParameters:\n\n  * **`config`** (`RunnableConfig`) \u2013 \n\nThe config to associate with the checkpoint.\n\n  * **`checkpoint`** (`Checkpoint`) \u2013 \n\nThe checkpoint to save.\n\n  * **`metadata`** (`CheckpointMetadata`) \u2013 \n\nAdditional metadata to save with the checkpoint.\n\n  * **`new_versions`** (`ChannelVersions`) \u2013 \n\nNew channel versions as of this write.\n\n\n\n\nReturns:\n\n  * **`RunnableConfig`** ( `RunnableConfig` ) \u2013 \n\nUpdated configuration after storing the checkpoint.\n\n\n\n\nExamples:\n[code] \n    >>> from langgraph.checkpoint.sqlite import SqliteSaver\n    >>> with SqliteSaver.from_conn_string(\":memory:\") as memory:\n    >>>     config = {\"configurable\": {\"thread_id\": \"1\", \"checkpoint_ns\": \"\"}}\n    >>>     checkpoint = {\"ts\": \"2024-05-04T06:32:42.235444+00:00\", \"id\": \"1ef4f797-8335-6428-8001-8a1503f9b875\", \"channel_values\": {\"key\": \"value\"}}\n    >>>     saved_config = memory.put(config, checkpoint, {\"source\": \"input\", \"step\": 1, \"writes\": {\"key\": \"value\"}}, {})\n    >>> print(saved_config)\n    {'configurable': {'thread_id': '1', 'checkpoint_ns': '', 'checkpoint_id': '1ef4f797-8335-6428-8001-8a1503f9b875'}}\n    \n[/code]\n\n###  `` `put_writes(config: RunnableConfig, writes: Sequence[Tuple[str, Any]], task_id: str, task_path: str = '') -> None` \u00b6\n\nStore intermediate writes linked to a checkpoint.\n\nThis method saves intermediate writes associated with a checkpoint to the SQLite database.\n\nParameters:\n\n  * **`config`** (`RunnableConfig`) \u2013 \n\nConfiguration of the related checkpoint.\n\n  * **`writes`** (`Sequence[Tuple[str, Any]]`) \u2013 \n\nList of writes to store, each as (channel, value) pair.\n\n  * **`task_id`** (`str`) \u2013 \n\nIdentifier for the task creating the writes.\n\n  * **`task_path`** (`str`, default: `''` ) \u2013 \n\nPath of the task creating the writes.\n\n\n\n\n###  `` `aget_tuple(config: RunnableConfig) -> Optional[CheckpointTuple]` `async` \u00b6\n\nGet a checkpoint tuple from the database asynchronously.\n\nNote\n\nThis async method is not supported by the SqliteSaver class. Use get_tuple() instead, or consider using AsyncSqliteSaver.\n\n###  `` `alist(config: Optional[RunnableConfig], *, filter: Optional[Dict[str, Any]] = None, before: Optional[RunnableConfig] = None, limit: Optional[int] = None) -> AsyncIterator[CheckpointTuple]` `async` \u00b6\n\nList checkpoints from the database asynchronously.\n\nNote\n\nThis async method is not supported by the SqliteSaver class. Use list() instead, or consider using AsyncSqliteSaver.\n\n###  `` `aput(config: RunnableConfig, checkpoint: Checkpoint, metadata: CheckpointMetadata, new_versions: ChannelVersions) -> RunnableConfig` `async` \u00b6\n\nSave a checkpoint to the database asynchronously.\n\nNote\n\nThis async method is not supported by the SqliteSaver class. Use put() instead, or consider using AsyncSqliteSaver.\n\n###  `` `get_next_version(current: Optional[str], channel: ChannelProtocol) -> str` \u00b6\n\nGenerate the next version ID for a channel.\n\nThis method creates a new version identifier for a channel based on its current version.\n\nParameters:\n\n  * **`current`** (`Optional[str]`) \u2013 \n\nThe current version identifier of the channel.\n\n  * **`channel`** (`BaseChannel`) \u2013 \n\nThe channel being versioned.\n\n\n\n\nReturns:\n\n  * **`str`** ( `str` ) \u2013 \n\nThe next version identifier, which is guaranteed to be monotonically increasing.\n\n\n\n\n##  `` `AsyncSqliteSaver` \u00b6\n\nBases: `BaseCheckpointSaver[str]`\n\nAn asynchronous checkpoint saver that stores checkpoints in a SQLite database.\n\nThis class provides an asynchronous interface for saving and retrieving checkpoints using a SQLite database. It's designed for use in asynchronous environments and offers better performance for I/O-bound operations compared to synchronous alternatives.\n\nAttributes:\n\n  * **`conn`** (`Connection`) \u2013 \n\nThe asynchronous SQLite database connection.\n\n  * **`serde`** (`SerializerProtocol`) \u2013 \n\nThe serializer used for encoding/decoding checkpoints.\n\n\nTip\n\nRequires the aiosqlite package. Install it with `pip install aiosqlite`.\n\nWarning\n\nWhile this class supports asynchronous checkpointing, it is not recommended for production workloads due to limitations in SQLite's write performance. For production use, consider a more robust database like PostgreSQL.\n\nTip\n\nRemember to **close the database connection** after executing your code, otherwise, you may see the graph \"hang\" after execution (since the program will not exit until the connection is closed).\n\nThe easiest way is to use the `async with` statement as shown in the examples.\n[code] \n    async with AsyncSqliteSaver.from_conn_string(\"checkpoints.sqlite\") as saver:\n        # Your code here\n        graph = builder.compile(checkpointer=saver)\n        config = {\"configurable\": {\"thread_id\": \"thread-1\"}}\n        async for event in graph.astream_events(..., config, version=\"v1\"):\n            print(event)\n    \n[/code]\n\nExamples:\n\nUsage within StateGraph:\n[code] \n    >>> import asyncio\n    >>>\n    >>> from langgraph.checkpoint.sqlite.aio import AsyncSqliteSaver\n    >>> from langgraph.graph import StateGraph\n    >>>\n    >>> builder = StateGraph(int)\n    >>> builder.add_node(\"add_one\", lambda x: x + 1)\n    >>> builder.set_entry_point(\"add_one\")\n    >>> builder.set_finish_point(\"add_one\")\n    >>> async with AsyncSqliteSaver.from_conn_string(\"checkpoints.db\") as memory:\n    >>>     graph = builder.compile(checkpointer=memory)\n    >>>     coro = graph.ainvoke(1, {\"configurable\": {\"thread_id\": \"thread-1\"}})\n    >>>     print(asyncio.run(coro))\n    Output: 2\n    \n[/code]\n\nRaw usage:\n[code] \n    >>> import asyncio\n    >>> import aiosqlite\n    >>> from langgraph.checkpoint.sqlite.aio import AsyncSqliteSaver\n    >>>\n    >>> async def main():\n    >>>     async with aiosqlite.connect(\"checkpoints.db\") as conn:\n    ...         saver = AsyncSqliteSaver(conn)\n    ...         config = {\"configurable\": {\"thread_id\": \"1\"}}\n    ...         checkpoint = {\"ts\": \"2023-05-03T10:00:00Z\", \"data\": {\"key\": \"value\"}}\n    ...         saved_config = await saver.aput(config, checkpoint, {}, {})\n    ...         print(saved_config)\n    >>> asyncio.run(main())\n    {\"configurable\": {\"thread_id\": \"1\", \"checkpoint_id\": \"0c62ca34-ac19-445d-bbb0-5b4984975b2a\"}}\n    \n[/code]\n\n###  `` `config_specs: list[ConfigurableFieldSpec]` `property` \u00b6\n\nDefine the configuration options for the checkpoint saver.\n\nReturns:\n\n  * `list[ConfigurableFieldSpec]` \u2013 \n\nlist[ConfigurableFieldSpec]: List of configuration field specs.\n\n\n\n\n###  `` `get(config: RunnableConfig) -> Optional[Checkpoint]` \u00b6\n\nFetch a checkpoint using the given configuration.\n\nParameters:\n\n  * **`config`** (`RunnableConfig`) \u2013 \n\nConfiguration specifying which checkpoint to retrieve.\n\n\n\n\nReturns:\n\n  * `Optional[Checkpoint]` \u2013 \n\nOptional[Checkpoint]: The requested checkpoint, or None if not found.\n\n\n\n\n###  `` `aget(config: RunnableConfig) -> Optional[Checkpoint]` `async` \u00b6\n\nAsynchronously fetch a checkpoint using the given configuration.\n\nParameters:\n\n  * **`config`** (`RunnableConfig`) \u2013 \n\nConfiguration specifying which checkpoint to retrieve.\n\n\n\n\nReturns:\n\n  * `Optional[Checkpoint]` \u2013 \n\nOptional[Checkpoint]: The requested checkpoint, or None if not found.\n\n\n\n\n###  `` `from_conn_string(conn_string: str) -> AsyncIterator[AsyncSqliteSaver]` `async` `classmethod` \u00b6\n\nCreate a new AsyncSqliteSaver instance from a connection string.\n\nParameters:\n\n  * **`conn_string`** (`str`) \u2013 \n\nThe SQLite connection string.\n\n\n\n\nYields:\n\n  * **`AsyncSqliteSaver`** ( `AsyncIterator[AsyncSqliteSaver]` ) \u2013 \n\nA new AsyncSqliteSaver instance.\n\n\n\n\n###  `` `get_tuple(config: RunnableConfig) -> Optional[CheckpointTuple]` \u00b6\n\nGet a checkpoint tuple from the database.\n\nThis method retrieves a checkpoint tuple from the SQLite database based on the provided config. If the config contains a \"checkpoint_id\" key, the checkpoint with the matching thread ID and checkpoint ID is retrieved. Otherwise, the latest checkpoint for the given thread ID is retrieved.\n\nParameters:\n\n  * **`config`** (`RunnableConfig`) \u2013 \n\nThe config to use for retrieving the checkpoint.\n\n\n\n\nReturns:\n\n  * `Optional[CheckpointTuple]` \u2013 \n\nOptional[CheckpointTuple]: The retrieved checkpoint tuple, or None if no matching checkpoint was found.\n\n\n\n\n###  `` `list(config: Optional[RunnableConfig], *, filter: Optional[dict[str, Any]] = None, before: Optional[RunnableConfig] = None, limit: Optional[int] = None) -> Iterator[CheckpointTuple]` \u00b6\n\nList checkpoints from the database asynchronously.\n\nThis method retrieves a list of checkpoint tuples from the SQLite database based on the provided config. The checkpoints are ordered by checkpoint ID in descending order (newest first).\n\nParameters:\n\n  * **`config`** (`Optional[RunnableConfig]`) \u2013 \n\nBase configuration for filtering checkpoints.\n\n  * **`filter`** (`Optional[Dict[str, Any]]`, default: `None` ) \u2013 \n\nAdditional filtering criteria for metadata.\n\n  * **`before`** (`Optional[RunnableConfig]`, default: `None` ) \u2013 \n\nIf provided, only checkpoints before the specified checkpoint ID are returned. Defaults to None.\n\n  * **`limit`** (`Optional[int]`, default: `None` ) \u2013 \n\nMaximum number of checkpoints to return.\n\n\n\n\nYields:\n\n  * `CheckpointTuple` \u2013 \n\nIterator[CheckpointTuple]: An iterator of matching checkpoint tuples.\n\n\n\n\n###  `` `put(config: RunnableConfig, checkpoint: Checkpoint, metadata: CheckpointMetadata, new_versions: ChannelVersions) -> RunnableConfig` \u00b6\n\nSave a checkpoint to the database.\n\nThis method saves a checkpoint to the SQLite database. The checkpoint is associated with the provided config and its parent config (if any).\n\nParameters:\n\n  * **`config`** (`RunnableConfig`) \u2013 \n\nThe config to associate with the checkpoint.\n\n  * **`checkpoint`** (`Checkpoint`) \u2013 \n\nThe checkpoint to save.\n\n  * **`metadata`** (`CheckpointMetadata`) \u2013 \n\nAdditional metadata to save with the checkpoint.\n\n  * **`new_versions`** (`ChannelVersions`) \u2013 \n\nNew channel versions as of this write.\n\n\n\n\nReturns:\n\n  * **`RunnableConfig`** ( `RunnableConfig` ) \u2013 \n\nUpdated configuration after storing the checkpoint.\n\n\n\n\n###  `` `setup() -> None` `async` \u00b6\n\nSet up the checkpoint database asynchronously.\n\nThis method creates the necessary tables in the SQLite database if they don't already exist. It is called automatically when needed and should not be called directly by the user.\n\n###  `` `aget_tuple(config: RunnableConfig) -> Optional[CheckpointTuple]` `async` \u00b6\n\nGet a checkpoint tuple from the database asynchronously.\n\nThis method retrieves a checkpoint tuple from the SQLite database based on the provided config. If the config contains a \"checkpoint_id\" key, the checkpoint with the matching thread ID and checkpoint ID is retrieved. Otherwise, the latest checkpoint for the given thread ID is retrieved.\n\nParameters:\n\n  * **`config`** (`RunnableConfig`) \u2013 \n\nThe config to use for retrieving the checkpoint.\n\n\n\n\nReturns:\n\n  * `Optional[CheckpointTuple]` \u2013 \n\nOptional[CheckpointTuple]: The retrieved checkpoint tuple, or None if no matching checkpoint was found.\n\n\n\n\n###  `` `alist(config: Optional[RunnableConfig], *, filter: Optional[dict[str, Any]] = None, before: Optional[RunnableConfig] = None, limit: Optional[int] = None) -> AsyncIterator[CheckpointTuple]` `async` \u00b6\n\nList checkpoints from the database asynchronously.\n\nThis method retrieves a list of checkpoint tuples from the SQLite database based on the provided config. The checkpoints are ordered by checkpoint ID in descending order (newest first).\n\nParameters:\n\n  * **`config`** (`Optional[RunnableConfig]`) \u2013 \n\nBase configuration for filtering checkpoints.\n\n  * **`filter`** (`Optional[Dict[str, Any]]`, default: `None` ) \u2013 \n\nAdditional filtering criteria for metadata.\n\n  * **`before`** (`Optional[RunnableConfig]`, default: `None` ) \u2013 \n\nIf provided, only checkpoints before the specified checkpoint ID are returned. Defaults to None.\n\n  * **`limit`** (`Optional[int]`, default: `None` ) \u2013 \n\nMaximum number of checkpoints to return.\n\n\n\n\nYields:\n\n  * `AsyncIterator[CheckpointTuple]` \u2013 \n\nAsyncIterator[CheckpointTuple]: An asynchronous iterator of matching checkpoint tuples.\n\n\n\n\n###  `` `aput(config: RunnableConfig, checkpoint: Checkpoint, metadata: CheckpointMetadata, new_versions: ChannelVersions) -> RunnableConfig` `async` \u00b6\n\nSave a checkpoint to the database asynchronously.\n\nThis method saves a checkpoint to the SQLite database. The checkpoint is associated with the provided config and its parent config (if any).\n\nParameters:\n\n  * **`config`** (`RunnableConfig`) \u2013 \n\nThe config to associate with the checkpoint.\n\n  * **`checkpoint`** (`Checkpoint`) \u2013 \n\nThe checkpoint to save.\n\n  * **`metadata`** (`CheckpointMetadata`) \u2013 \n\nAdditional metadata to save with the checkpoint.\n\n  * **`new_versions`** (`ChannelVersions`) \u2013 \n\nNew channel versions as of this write.\n\n\n\n\nReturns:\n\n  * **`RunnableConfig`** ( `RunnableConfig` ) \u2013 \n\nUpdated configuration after storing the checkpoint.\n\n\n\n\n###  `` `aput_writes(config: RunnableConfig, writes: Sequence[tuple[str, Any]], task_id: str, task_path: str = '') -> None` `async` \u00b6\n\nStore intermediate writes linked to a checkpoint asynchronously.\n\nThis method saves intermediate writes associated with a checkpoint to the database.\n\nParameters:\n\n  * **`config`** (`RunnableConfig`) \u2013 \n\nConfiguration of the related checkpoint.\n\n  * **`writes`** (`Sequence[Tuple[str, Any]]`) \u2013 \n\nList of writes to store, each as (channel, value) pair.\n\n  * **`task_id`** (`str`) \u2013 \n\nIdentifier for the task creating the writes.\n\n  * **`task_path`** (`str`, default: `''` ) \u2013 \n\nPath of the task creating the writes.\n\n\n\n\n###  `` `get_next_version(current: Optional[str], channel: ChannelProtocol) -> str` \u00b6\n\nGenerate the next version ID for a channel.\n\nThis method creates a new version identifier for a channel based on its current version.\n\nParameters:\n\n  * **`current`** (`Optional[str]`) \u2013 \n\nThe current version identifier of the channel.\n\n  * **`channel`** (`BaseChannel`) \u2013 \n\nThe channel being versioned.\n\n\n\n\nReturns:\n\n  * **`str`** ( `str` ) \u2013 \n\nThe next version identifier, which is guaranteed to be monotonically increasing.\n\n\n\n\n##  `` `BasePostgresSaver` \u00b6\n\nBases: `BaseCheckpointSaver[str]`\n\n###  `` `config_specs: list[ConfigurableFieldSpec]` `property` \u00b6\n\nDefine the configuration options for the checkpoint saver.\n\nReturns:\n\n  * `list[ConfigurableFieldSpec]` \u2013 \n\nlist[ConfigurableFieldSpec]: List of configuration field specs.\n\n\n\n\n###  `` `get(config: RunnableConfig) -> Optional[Checkpoint]` \u00b6\n\nFetch a checkpoint using the given configuration.\n\nParameters:\n\n  * **`config`** (`RunnableConfig`) \u2013 \n\nConfiguration specifying which checkpoint to retrieve.\n\n\n\n\nReturns:\n\n  * `Optional[Checkpoint]` \u2013 \n\nOptional[Checkpoint]: The requested checkpoint, or None if not found.\n\n\n\n\n###  `` `get_tuple(config: RunnableConfig) -> Optional[CheckpointTuple]` \u00b6\n\nFetch a checkpoint tuple using the given configuration.\n\nParameters:\n\n  * **`config`** (`RunnableConfig`) \u2013 \n\nConfiguration specifying which checkpoint to retrieve.\n\n\n\n\nReturns:\n\n  * `Optional[CheckpointTuple]` \u2013 \n\nOptional[CheckpointTuple]: The requested checkpoint tuple, or None if not found.\n\n\n\n\nRaises:\n\n  * `NotImplementedError` \u2013 \n\nImplement this method in your custom checkpoint saver.\n\n\n\n\n###  `` `list(config: Optional[RunnableConfig], *, filter: Optional[Dict[str, Any]] = None, before: Optional[RunnableConfig] = None, limit: Optional[int] = None) -> Iterator[CheckpointTuple]` \u00b6\n\nList checkpoints that match the given criteria.\n\nParameters:\n\n  * **`config`** (`Optional[RunnableConfig]`) \u2013 \n\nBase configuration for filtering checkpoints.\n\n  * **`filter`** (`Optional[Dict[str, Any]]`, default: `None` ) \u2013 \n\nAdditional filtering criteria.\n\n  * **`before`** (`Optional[RunnableConfig]`, default: `None` ) \u2013 \n\nList checkpoints created before this configuration.\n\n  * **`limit`** (`Optional[int]`, default: `None` ) \u2013 \n\nMaximum number of checkpoints to return.\n\n\n\n\nReturns:\n\n  * `Iterator[CheckpointTuple]` \u2013 \n\nIterator[CheckpointTuple]: Iterator of matching checkpoint tuples.\n\n\n\n\nRaises:\n\n  * `NotImplementedError` \u2013 \n\nImplement this method in your custom checkpoint saver.\n\n\n\n\n###  `` `put(config: RunnableConfig, checkpoint: Checkpoint, metadata: CheckpointMetadata, new_versions: ChannelVersions) -> RunnableConfig` \u00b6\n\nStore a checkpoint with its configuration and metadata.\n\nParameters:\n\n  * **`config`** (`RunnableConfig`) \u2013 \n\nConfiguration for the checkpoint.\n\n  * **`checkpoint`** (`Checkpoint`) \u2013 \n\nThe checkpoint to store.\n\n  * **`metadata`** (`CheckpointMetadata`) \u2013 \n\nAdditional metadata for the checkpoint.\n\n  * **`new_versions`** (`ChannelVersions`) \u2013 \n\nNew channel versions as of this write.\n\n\n\n\nReturns:\n\n  * **`RunnableConfig`** ( `RunnableConfig` ) \u2013 \n\nUpdated configuration after storing the checkpoint.\n\n\n\n\nRaises:\n\n  * `NotImplementedError` \u2013 \n\nImplement this method in your custom checkpoint saver.\n\n\n\n\n###  `` `put_writes(config: RunnableConfig, writes: Sequence[Tuple[str, Any]], task_id: str, task_path: str = '') -> None` \u00b6\n\nStore intermediate writes linked to a checkpoint.\n\nParameters:\n\n  * **`config`** (`RunnableConfig`) \u2013 \n\nConfiguration of the related checkpoint.\n\n  * **`writes`** (`List[Tuple[str, Any]]`) \u2013 \n\nList of writes to store.\n\n  * **`task_id`** (`str`) \u2013 \n\nIdentifier for the task creating the writes.\n\n  * **`task_path`** (`str`, default: `''` ) \u2013 \n\nPath of the task creating the writes.\n\n\n\n\nRaises:\n\n  * `NotImplementedError` \u2013 \n\nImplement this method in your custom checkpoint saver.\n\n\n\n\n###  `` `aget(config: RunnableConfig) -> Optional[Checkpoint]` `async` \u00b6\n\nAsynchronously fetch a checkpoint using the given configuration.\n\nParameters:\n\n  * **`config`** (`RunnableConfig`) \u2013 \n\nConfiguration specifying which checkpoint to retrieve.\n\n\n\n\nReturns:\n\n  * `Optional[Checkpoint]` \u2013 \n\nOptional[Checkpoint]: The requested checkpoint, or None if not found.\n\n\n\n\n###  `` `aget_tuple(config: RunnableConfig) -> Optional[CheckpointTuple]` `async` \u00b6\n\nAsynchronously fetch a checkpoint tuple using the given configuration.\n\nParameters:\n\n  * **`config`** (`RunnableConfig`) \u2013 \n\nConfiguration specifying which checkpoint to retrieve.\n\n\n\n\nReturns:\n\n  * `Optional[CheckpointTuple]` \u2013 \n\nOptional[CheckpointTuple]: The requested checkpoint tuple, or None if not found.\n\n\n\n\nRaises:\n\n  * `NotImplementedError` \u2013 \n\nImplement this method in your custom checkpoint saver.\n\n\n\n\n###  `` `alist(config: Optional[RunnableConfig], *, filter: Optional[Dict[str, Any]] = None, before: Optional[RunnableConfig] = None, limit: Optional[int] = None) -> AsyncIterator[CheckpointTuple]` `async` \u00b6\n\nAsynchronously list checkpoints that match the given criteria.\n\nParameters:\n\n  * **`config`** (`Optional[RunnableConfig]`) \u2013 \n\nBase configuration for filtering checkpoints.\n\n  * **`filter`** (`Optional[Dict[str, Any]]`, default: `None` ) \u2013 \n\nAdditional filtering criteria for metadata.\n\n  * **`before`** (`Optional[RunnableConfig]`, default: `None` ) \u2013 \n\nList checkpoints created before this configuration.\n\n  * **`limit`** (`Optional[int]`, default: `None` ) \u2013 \n\nMaximum number of checkpoints to return.\n\n\n\n\nReturns:\n\n  * `AsyncIterator[CheckpointTuple]` \u2013 \n\nAsyncIterator[CheckpointTuple]: Async iterator of matching checkpoint tuples.\n\n\n\n\nRaises:\n\n  * `NotImplementedError` \u2013 \n\nImplement this method in your custom checkpoint saver.\n\n\n\n\n###  `` `aput(config: RunnableConfig, checkpoint: Checkpoint, metadata: CheckpointMetadata, new_versions: ChannelVersions) -> RunnableConfig` `async` \u00b6\n\nAsynchronously store a checkpoint with its configuration and metadata.\n\nParameters:\n\n  * **`config`** (`RunnableConfig`) \u2013 \n\nConfiguration for the checkpoint.\n\n  * **`checkpoint`** (`Checkpoint`) \u2013 \n\nThe checkpoint to store.\n\n  * **`metadata`** (`CheckpointMetadata`) \u2013 \n\nAdditional metadata for the checkpoint.\n\n  * **`new_versions`** (`ChannelVersions`) \u2013 \n\nNew channel versions as of this write.\n\n\n\n\nReturns:\n\n  * **`RunnableConfig`** ( `RunnableConfig` ) \u2013 \n\nUpdated configuration after storing the checkpoint.\n\n\n\n\nRaises:\n\n  * `NotImplementedError` \u2013 \n\nImplement this method in your custom checkpoint saver.\n\n\n\n\n###  `` `aput_writes(config: RunnableConfig, writes: Sequence[Tuple[str, Any]], task_id: str, task_path: str = '') -> None` `async` \u00b6\n\nAsynchronously store intermediate writes linked to a checkpoint.\n\nParameters:\n\n  * **`config`** (`RunnableConfig`) \u2013 \n\nConfiguration of the related checkpoint.\n\n  * **`writes`** (`List[Tuple[str, Any]]`) \u2013 \n\nList of writes to store.\n\n  * **`task_id`** (`str`) \u2013 \n\nIdentifier for the task creating the writes.\n\n  * **`task_path`** (`str`, default: `''` ) \u2013 \n\nPath of the task creating the writes.\n\n\n\n\nRaises:\n\n  * `NotImplementedError` \u2013 \n\nImplement this method in your custom checkpoint saver.\n\n\n\n\n##  `` `ShallowPostgresSaver` \u00b6\n\nBases: `BasePostgresSaver`\n\nA checkpoint saver that uses Postgres to store checkpoints.\n\nThis checkpointer ONLY stores the most recent checkpoint and does NOT retain any history. It is meant to be a light-weight drop-in replacement for the PostgresSaver that supports most of the LangGraph persistence functionality with the exception of time travel.\n\n###  `` `config_specs: list[ConfigurableFieldSpec]` `property` \u00b6\n\nDefine the configuration options for the checkpoint saver.\n\nReturns:\n\n  * `list[ConfigurableFieldSpec]` \u2013 \n\nlist[ConfigurableFieldSpec]: List of configuration field specs.\n\n\n\n\n###  `` `get(config: RunnableConfig) -> Optional[Checkpoint]` \u00b6\n\nFetch a checkpoint using the given configuration.\n\nParameters:\n\n  * **`config`** (`RunnableConfig`) \u2013 \n\nConfiguration specifying which checkpoint to retrieve.\n\n\n\n\nReturns:\n\n  * `Optional[Checkpoint]` \u2013 \n\nOptional[Checkpoint]: The requested checkpoint, or None if not found.\n\n\n\n\n###  `` `aget(config: RunnableConfig) -> Optional[Checkpoint]` `async` \u00b6\n\nAsynchronously fetch a checkpoint using the given configuration.\n\nParameters:\n\n  * **`config`** (`RunnableConfig`) \u2013 \n\nConfiguration specifying which checkpoint to retrieve.\n\n\n\n\nReturns:\n\n  * `Optional[Checkpoint]` \u2013 \n\nOptional[Checkpoint]: The requested checkpoint, or None if not found.\n\n\n\n\n###  `` `aget_tuple(config: RunnableConfig) -> Optional[CheckpointTuple]` `async` \u00b6\n\nAsynchronously fetch a checkpoint tuple using the given configuration.\n\nParameters:\n\n  * **`config`** (`RunnableConfig`) \u2013 \n\nConfiguration specifying which checkpoint to retrieve.\n\n\n\n\nReturns:\n\n  * `Optional[CheckpointTuple]` \u2013 \n\nOptional[CheckpointTuple]: The requested checkpoint tuple, or None if not found.\n\n\n\n\nRaises:\n\n  * `NotImplementedError` \u2013 \n\nImplement this method in your custom checkpoint saver.\n\n\n\n\n###  `` `alist(config: Optional[RunnableConfig], *, filter: Optional[Dict[str, Any]] = None, before: Optional[RunnableConfig] = None, limit: Optional[int] = None) -> AsyncIterator[CheckpointTuple]` `async` \u00b6\n\nAsynchronously list checkpoints that match the given criteria.\n\nParameters:\n\n  * **`config`** (`Optional[RunnableConfig]`) \u2013 \n\nBase configuration for filtering checkpoints.\n\n  * **`filter`** (`Optional[Dict[str, Any]]`, default: `None` ) \u2013 \n\nAdditional filtering criteria for metadata.\n\n  * **`before`** (`Optional[RunnableConfig]`, default: `None` ) \u2013 \n\nList checkpoints created before this configuration.\n\n  * **`limit`** (`Optional[int]`, default: `None` ) \u2013 \n\nMaximum number of checkpoints to return.\n\n\n\n\nReturns:\n\n  * `AsyncIterator[CheckpointTuple]` \u2013 \n\nAsyncIterator[CheckpointTuple]: Async iterator of matching checkpoint tuples.\n\n\n\n\nRaises:\n\n  * `NotImplementedError` \u2013 \n\nImplement this method in your custom checkpoint saver.\n\n\n\n\n###  `` `aput(config: RunnableConfig, checkpoint: Checkpoint, metadata: CheckpointMetadata, new_versions: ChannelVersions) -> RunnableConfig` `async` \u00b6\n\nAsynchronously store a checkpoint with its configuration and metadata.\n\nParameters:\n\n  * **`config`** (`RunnableConfig`) \u2013 \n\nConfiguration for the checkpoint.\n\n  * **`checkpoint`** (`Checkpoint`) \u2013 \n\nThe checkpoint to store.\n\n  * **`metadata`** (`CheckpointMetadata`) \u2013 \n\nAdditional metadata for the checkpoint.\n\n  * **`new_versions`** (`ChannelVersions`) \u2013 \n\nNew channel versions as of this write.\n\n\n\n\nReturns:\n\n  * **`RunnableConfig`** ( `RunnableConfig` ) \u2013 \n\nUpdated configuration after storing the checkpoint.\n\n\n\n\nRaises:\n\n  * `NotImplementedError` \u2013 \n\nImplement this method in your custom checkpoint saver.\n\n\n\n\n###  `` `aput_writes(config: RunnableConfig, writes: Sequence[Tuple[str, Any]], task_id: str, task_path: str = '') -> None` `async` \u00b6\n\nAsynchronously store intermediate writes linked to a checkpoint.\n\nParameters:\n\n  * **`config`** (`RunnableConfig`) \u2013 \n\nConfiguration of the related checkpoint.\n\n  * **`writes`** (`List[Tuple[str, Any]]`) \u2013 \n\nList of writes to store.\n\n  * **`task_id`** (`str`) \u2013 \n\nIdentifier for the task creating the writes.\n\n  * **`task_path`** (`str`, default: `''` ) \u2013 \n\nPath of the task creating the writes.\n\n\n\n\nRaises:\n\n  * `NotImplementedError` \u2013 \n\nImplement this method in your custom checkpoint saver.\n\n\n\n\n###  `` `from_conn_string(conn_string: str, *, pipeline: bool = False) -> Iterator[ShallowPostgresSaver]` `classmethod` \u00b6\n\nCreate a new ShallowPostgresSaver instance from a connection string.\n\nParameters:\n\n  * **`conn_string`** (`str`) \u2013 \n\nThe Postgres connection info string.\n\n  * **`pipeline`** (`bool`, default: `False` ) \u2013 \n\nwhether to use Pipeline\n\n\n\n\nReturns:\n\n  * **`ShallowPostgresSaver`** ( `Iterator[ShallowPostgresSaver]` ) \u2013 \n\nA new ShallowPostgresSaver instance.\n\n\n\n\n###  `` `setup() -> None` \u00b6\n\nSet up the checkpoint database asynchronously.\n\nThis method creates the necessary tables in the Postgres database if they don't already exist and runs database migrations. It MUST be called directly by the user the first time checkpointer is used.\n\n###  `` `list(config: Optional[RunnableConfig], *, filter: Optional[dict[str, Any]] = None, before: Optional[RunnableConfig] = None, limit: Optional[int] = None) -> Iterator[CheckpointTuple]` \u00b6\n\nList checkpoints from the database.\n\nThis method retrieves a list of checkpoint tuples from the Postgres database based on the provided config. For ShallowPostgresSaver, this method returns a list with ONLY the most recent checkpoint.\n\n###  `` `get_tuple(config: RunnableConfig) -> Optional[CheckpointTuple]` \u00b6\n\nGet a checkpoint tuple from the database.\n\nThis method retrieves a checkpoint tuple from the Postgres database based on the provided config (matching the thread ID in the config).\n\nParameters:\n\n  * **`config`** (`RunnableConfig`) \u2013 \n\nThe config to use for retrieving the checkpoint.\n\n\n\n\nReturns:\n\n  * `Optional[CheckpointTuple]` \u2013 \n\nOptional[CheckpointTuple]: The retrieved checkpoint tuple, or None if no matching checkpoint was found.\n\n\n\n\nExamples:\n[code] \n    Basic:\n    >>> config = {\"configurable\": {\"thread_id\": \"1\"}}\n    >>> checkpoint_tuple = memory.get_tuple(config)\n    >>> print(checkpoint_tuple)\n    CheckpointTuple(...)\n    \n    With timestamp:\n    \n    >>> config = {\n    ...    \"configurable\": {\n    ...        \"thread_id\": \"1\",\n    ...        \"checkpoint_ns\": \"\",\n    ...        \"checkpoint_id\": \"1ef4f797-8335-6428-8001-8a1503f9b875\",\n    ...    }\n    ... }\n    >>> checkpoint_tuple = memory.get_tuple(config)\n    >>> print(checkpoint_tuple)\n    CheckpointTuple(...)\n    \n[/code]\n\n###  `` `put(config: RunnableConfig, checkpoint: Checkpoint, metadata: CheckpointMetadata, new_versions: ChannelVersions) -> RunnableConfig` \u00b6\n\nSave a checkpoint to the database.\n\nThis method saves a checkpoint to the Postgres database. The checkpoint is associated with the provided config. For ShallowPostgresSaver, this method saves ONLY the most recent checkpoint and overwrites a previous checkpoint, if it exists.\n\nParameters:\n\n  * **`config`** (`RunnableConfig`) \u2013 \n\nThe config to associate with the checkpoint.\n\n  * **`checkpoint`** (`Checkpoint`) \u2013 \n\nThe checkpoint to save.\n\n  * **`metadata`** (`CheckpointMetadata`) \u2013 \n\nAdditional metadata to save with the checkpoint.\n\n  * **`new_versions`** (`ChannelVersions`) \u2013 \n\nNew channel versions as of this write.\n\n\n\n\nReturns:\n\n  * **`RunnableConfig`** ( `RunnableConfig` ) \u2013 \n\nUpdated configuration after storing the checkpoint.\n\n\n\n\nExamples:\n[code] \n    >>> from langgraph.checkpoint.postgres import ShallowPostgresSaver\n    >>> DB_URI = \"postgres://postgres:postgres@localhost:5432/postgres?sslmode=disable\"\n    >>> with ShallowPostgresSaver.from_conn_string(DB_URI) as memory:\n    >>>     config = {\"configurable\": {\"thread_id\": \"1\", \"checkpoint_ns\": \"\"}}\n    >>>     checkpoint = {\"ts\": \"2024-05-04T06:32:42.235444+00:00\", \"id\": \"1ef4f797-8335-6428-8001-8a1503f9b875\", \"channel_values\": {\"key\": \"value\"}}\n    >>>     saved_config = memory.put(config, checkpoint, {\"source\": \"input\", \"step\": 1, \"writes\": {\"key\": \"value\"}}, {})\n    >>> print(saved_config)\n    {'configurable': {'thread_id': '1', 'checkpoint_ns': '', 'checkpoint_id': '1ef4f797-8335-6428-8001-8a1503f9b875'}}\n    \n[/code]\n\n###  `` `put_writes(config: RunnableConfig, writes: Sequence[tuple[str, Any]], task_id: str, task_path: str = '') -> None` \u00b6\n\nStore intermediate writes linked to a checkpoint.\n\nThis method saves intermediate writes associated with a checkpoint to the Postgres database.\n\nParameters:\n\n  * **`config`** (`RunnableConfig`) \u2013 \n\nConfiguration of the related checkpoint.\n\n  * **`writes`** (`List[Tuple[str, Any]]`) \u2013 \n\nList of writes to store.\n\n  * **`task_id`** (`str`) \u2013 \n\nIdentifier for the task creating the writes.\n\n\n\n\n##  `` `PostgresSaver` \u00b6\n\nBases: `BasePostgresSaver`\n\n###  `` `config_specs: list[ConfigurableFieldSpec]` `property` \u00b6\n\nDefine the configuration options for the checkpoint saver.\n\nReturns:\n\n  * `list[ConfigurableFieldSpec]` \u2013 \n\nlist[ConfigurableFieldSpec]: List of configuration field specs.\n\n\n\n\n###  `` `get(config: RunnableConfig) -> Optional[Checkpoint]` \u00b6\n\nFetch a checkpoint using the given configuration.\n\nParameters:\n\n  * **`config`** (`RunnableConfig`) \u2013 \n\nConfiguration specifying which checkpoint to retrieve.\n\n\n\n\nReturns:\n\n  * `Optional[Checkpoint]` \u2013 \n\nOptional[Checkpoint]: The requested checkpoint, or None if not found.\n\n\n\n\n###  `` `aget(config: RunnableConfig) -> Optional[Checkpoint]` `async` \u00b6\n\nAsynchronously fetch a checkpoint using the given configuration.\n\nParameters:\n\n  * **`config`** (`RunnableConfig`) \u2013 \n\nConfiguration specifying which checkpoint to retrieve.\n\n\n\n\nReturns:\n\n  * `Optional[Checkpoint]` \u2013 \n\nOptional[Checkpoint]: The requested checkpoint, or None if not found.\n\n\n\n\n###  `` `aget_tuple(config: RunnableConfig) -> Optional[CheckpointTuple]` `async` \u00b6\n\nAsynchronously fetch a checkpoint tuple using the given configuration.\n\nParameters:\n\n  * **`config`** (`RunnableConfig`) \u2013 \n\nConfiguration specifying which checkpoint to retrieve.\n\n\n\n\nReturns:\n\n  * `Optional[CheckpointTuple]` \u2013 \n\nOptional[CheckpointTuple]: The requested checkpoint tuple, or None if not found.\n\n\n\n\nRaises:\n\n  * `NotImplementedError` \u2013 \n\nImplement this method in your custom checkpoint saver.\n\n\n\n\n###  `` `alist(config: Optional[RunnableConfig], *, filter: Optional[Dict[str, Any]] = None, before: Optional[RunnableConfig] = None, limit: Optional[int] = None) -> AsyncIterator[CheckpointTuple]` `async` \u00b6\n\nAsynchronously list checkpoints that match the given criteria.\n\nParameters:\n\n  * **`config`** (`Optional[RunnableConfig]`) \u2013 \n\nBase configuration for filtering checkpoints.\n\n  * **`filter`** (`Optional[Dict[str, Any]]`, default: `None` ) \u2013 \n\nAdditional filtering criteria for metadata.\n\n  * **`before`** (`Optional[RunnableConfig]`, default: `None` ) \u2013 \n\nList checkpoints created before this configuration.\n\n  * **`limit`** (`Optional[int]`, default: `None` ) \u2013 \n\nMaximum number of checkpoints to return.\n\n\n\n\nReturns:\n\n  * `AsyncIterator[CheckpointTuple]` \u2013 \n\nAsyncIterator[CheckpointTuple]: Async iterator of matching checkpoint tuples.\n\n\n\n\nRaises:\n\n  * `NotImplementedError` \u2013 \n\nImplement this method in your custom checkpoint saver.\n\n\n\n\n###  `` `aput(config: RunnableConfig, checkpoint: Checkpoint, metadata: CheckpointMetadata, new_versions: ChannelVersions) -> RunnableConfig` `async` \u00b6\n\nAsynchronously store a checkpoint with its configuration and metadata.\n\nParameters:\n\n  * **`config`** (`RunnableConfig`) \u2013 \n\nConfiguration for the checkpoint.\n\n  * **`checkpoint`** (`Checkpoint`) \u2013 \n\nThe checkpoint to store.\n\n  * **`metadata`** (`CheckpointMetadata`) \u2013 \n\nAdditional metadata for the checkpoint.\n\n  * **`new_versions`** (`ChannelVersions`) \u2013 \n\nNew channel versions as of this write.\n\n\n\n\nReturns:\n\n  * **`RunnableConfig`** ( `RunnableConfig` ) \u2013 \n\nUpdated configuration after storing the checkpoint.\n\n\n\n\nRaises:\n\n  * `NotImplementedError` \u2013 \n\nImplement this method in your custom checkpoint saver.\n\n\n\n\n###  `` `aput_writes(config: RunnableConfig, writes: Sequence[Tuple[str, Any]], task_id: str, task_path: str = '') -> None` `async` \u00b6\n\nAsynchronously store intermediate writes linked to a checkpoint.\n\nParameters:\n\n  * **`config`** (`RunnableConfig`) \u2013 \n\nConfiguration of the related checkpoint.\n\n  * **`writes`** (`List[Tuple[str, Any]]`) \u2013 \n\nList of writes to store.\n\n  * **`task_id`** (`str`) \u2013 \n\nIdentifier for the task creating the writes.\n\n  * **`task_path`** (`str`, default: `''` ) \u2013 \n\nPath of the task creating the writes.\n\n\n\n\nRaises:\n\n  * `NotImplementedError` \u2013 \n\nImplement this method in your custom checkpoint saver.\n\n\n\n\n###  `` `from_conn_string(conn_string: str, *, pipeline: bool = False) -> Iterator[PostgresSaver]` `classmethod` \u00b6\n\nCreate a new PostgresSaver instance from a connection string.\n\nParameters:\n\n  * **`conn_string`** (`str`) \u2013 \n\nThe Postgres connection info string.\n\n  * **`pipeline`** (`bool`, default: `False` ) \u2013 \n\nwhether to use Pipeline\n\n\n\n\nReturns:\n\n  * **`PostgresSaver`** ( `Iterator[PostgresSaver]` ) \u2013 \n\nA new PostgresSaver instance.\n\n\n\n\n###  `` `setup() -> None` \u00b6\n\nSet up the checkpoint database asynchronously.\n\nThis method creates the necessary tables in the Postgres database if they don't already exist and runs database migrations. It MUST be called directly by the user the first time checkpointer is used.\n\n###  `` `list(config: Optional[RunnableConfig], *, filter: Optional[dict[str, Any]] = None, before: Optional[RunnableConfig] = None, limit: Optional[int] = None) -> Iterator[CheckpointTuple]` \u00b6\n\nList checkpoints from the database.\n\nThis method retrieves a list of checkpoint tuples from the Postgres database based on the provided config. The checkpoints are ordered by checkpoint ID in descending order (newest first).\n\nParameters:\n\n  * **`config`** (`RunnableConfig`) \u2013 \n\nThe config to use for listing the checkpoints.\n\n  * **`filter`** (`Optional[Dict[str, Any]]`, default: `None` ) \u2013 \n\nAdditional filtering criteria for metadata. Defaults to None.\n\n  * **`before`** (`Optional[RunnableConfig]`, default: `None` ) \u2013 \n\nIf provided, only checkpoints before the specified checkpoint ID are returned. Defaults to None.\n\n  * **`limit`** (`Optional[int]`, default: `None` ) \u2013 \n\nThe maximum number of checkpoints to return. Defaults to None.\n\n\n\n\nYields:\n\n  * `CheckpointTuple` \u2013 \n\nIterator[CheckpointTuple]: An iterator of checkpoint tuples.\n\n\n\n\nExamples:\n[code] \n    >>> from langgraph.checkpoint.postgres import PostgresSaver\n    >>> DB_URI = \"postgres://postgres:postgres@localhost:5432/postgres?sslmode=disable\"\n    >>> with PostgresSaver.from_conn_string(DB_URI) as memory:\n    ... # Run a graph, then list the checkpoints\n    >>>     config = {\"configurable\": {\"thread_id\": \"1\"}}\n    >>>     checkpoints = list(memory.list(config, limit=2))\n    >>> print(checkpoints)\n    [CheckpointTuple(...), CheckpointTuple(...)]\n    \n[/code]\n[code] \n    >>> config = {\"configurable\": {\"thread_id\": \"1\"}}\n    >>> before = {\"configurable\": {\"checkpoint_id\": \"1ef4f797-8335-6428-8001-8a1503f9b875\"}}\n    >>> with PostgresSaver.from_conn_string(DB_URI) as memory:\n    ... # Run a graph, then list the checkpoints\n    >>>     checkpoints = list(memory.list(config, before=before))\n    >>> print(checkpoints)\n    [CheckpointTuple(...), ...]\n    \n[/code]\n\n###  `` `get_tuple(config: RunnableConfig) -> Optional[CheckpointTuple]` \u00b6\n\nGet a checkpoint tuple from the database.\n\nThis method retrieves a checkpoint tuple from the Postgres database based on the provided config. If the config contains a \"checkpoint_id\" key, the checkpoint with the matching thread ID and timestamp is retrieved. Otherwise, the latest checkpoint for the given thread ID is retrieved.\n\nParameters:\n\n  * **`config`** (`RunnableConfig`) \u2013 \n\nThe config to use for retrieving the checkpoint.\n\n\n\n\nReturns:\n\n  * `Optional[CheckpointTuple]` \u2013 \n\nOptional[CheckpointTuple]: The retrieved checkpoint tuple, or None if no matching checkpoint was found.\n\n\n\n\nExamples:\n[code] \n    Basic:\n    >>> config = {\"configurable\": {\"thread_id\": \"1\"}}\n    >>> checkpoint_tuple = memory.get_tuple(config)\n    >>> print(checkpoint_tuple)\n    CheckpointTuple(...)\n    \n    With timestamp:\n    \n    >>> config = {\n    ...    \"configurable\": {\n    ...        \"thread_id\": \"1\",\n    ...        \"checkpoint_ns\": \"\",\n    ...        \"checkpoint_id\": \"1ef4f797-8335-6428-8001-8a1503f9b875\",\n    ...    }\n    ... }\n    >>> checkpoint_tuple = memory.get_tuple(config)\n    >>> print(checkpoint_tuple)\n    CheckpointTuple(...)\n    \n[/code]\n\n###  `` `put(config: RunnableConfig, checkpoint: Checkpoint, metadata: CheckpointMetadata, new_versions: ChannelVersions) -> RunnableConfig` \u00b6\n\nSave a checkpoint to the database.\n\nThis method saves a checkpoint to the Postgres database. The checkpoint is associated with the provided config and its parent config (if any).\n\nParameters:\n\n  * **`config`** (`RunnableConfig`) \u2013 \n\nThe config to associate with the checkpoint.\n\n  * **`checkpoint`** (`Checkpoint`) \u2013 \n\nThe checkpoint to save.\n\n  * **`metadata`** (`CheckpointMetadata`) \u2013 \n\nAdditional metadata to save with the checkpoint.\n\n  * **`new_versions`** (`ChannelVersions`) \u2013 \n\nNew channel versions as of this write.\n\n\n\n\nReturns:\n\n  * **`RunnableConfig`** ( `RunnableConfig` ) \u2013 \n\nUpdated configuration after storing the checkpoint.\n\n\n\n\nExamples:\n[code] \n    >>> from langgraph.checkpoint.postgres import PostgresSaver\n    >>> DB_URI = \"postgres://postgres:postgres@localhost:5432/postgres?sslmode=disable\"\n    >>> with PostgresSaver.from_conn_string(DB_URI) as memory:\n    >>>     config = {\"configurable\": {\"thread_id\": \"1\", \"checkpoint_ns\": \"\"}}\n    >>>     checkpoint = {\"ts\": \"2024-05-04T06:32:42.235444+00:00\", \"id\": \"1ef4f797-8335-6428-8001-8a1503f9b875\", \"channel_values\": {\"key\": \"value\"}}\n    >>>     saved_config = memory.put(config, checkpoint, {\"source\": \"input\", \"step\": 1, \"writes\": {\"key\": \"value\"}}, {})\n    >>> print(saved_config)\n    {'configurable': {'thread_id': '1', 'checkpoint_ns': '', 'checkpoint_id': '1ef4f797-8335-6428-8001-8a1503f9b875'}}\n    \n[/code]\n\n###  `` `put_writes(config: RunnableConfig, writes: Sequence[tuple[str, Any]], task_id: str, task_path: str = '') -> None` \u00b6\n\nStore intermediate writes linked to a checkpoint.\n\nThis method saves intermediate writes associated with a checkpoint to the Postgres database.\n\nParameters:\n\n  * **`config`** (`RunnableConfig`) \u2013 \n\nConfiguration of the related checkpoint.\n\n  * **`writes`** (`List[Tuple[str, Any]]`) \u2013 \n\nList of writes to store.\n\n  * **`task_id`** (`str`) \u2013 \n\nIdentifier for the task creating the writes.\n\n\n\n\n##  `` `AsyncShallowPostgresSaver` \u00b6\n\nBases: `BasePostgresSaver`\n\nA checkpoint saver that uses Postgres to store checkpoints asynchronously.\n\nThis checkpointer ONLY stores the most recent checkpoint and does NOT retain any history. It is meant to be a light-weight drop-in replacement for the AsyncPostgresSaver that supports most of the LangGraph persistence functionality with the exception of time travel.\n\n###  `` `config_specs: list[ConfigurableFieldSpec]` `property` \u00b6\n\nDefine the configuration options for the checkpoint saver.\n\nReturns:\n\n  * `list[ConfigurableFieldSpec]` \u2013 \n\nlist[ConfigurableFieldSpec]: List of configuration field specs.\n\n\n\n\n###  `` `get(config: RunnableConfig) -> Optional[Checkpoint]` \u00b6\n\nFetch a checkpoint using the given configuration.\n\nParameters:\n\n  * **`config`** (`RunnableConfig`) \u2013 \n\nConfiguration specifying which checkpoint to retrieve.\n\n\n\n\nReturns:\n\n  * `Optional[Checkpoint]` \u2013 \n\nOptional[Checkpoint]: The requested checkpoint, or None if not found.\n\n\n\n\n###  `` `aget(config: RunnableConfig) -> Optional[Checkpoint]` `async` \u00b6\n\nAsynchronously fetch a checkpoint using the given configuration.\n\nParameters:\n\n  * **`config`** (`RunnableConfig`) \u2013 \n\nConfiguration specifying which checkpoint to retrieve.\n\n\n\n\nReturns:\n\n  * `Optional[Checkpoint]` \u2013 \n\nOptional[Checkpoint]: The requested checkpoint, or None if not found.\n\n\n\n\n###  `` `from_conn_string(conn_string: str, *, pipeline: bool = False, serde: Optional[SerializerProtocol] = None) -> AsyncIterator[AsyncShallowPostgresSaver]` `async` `classmethod` \u00b6\n\nCreate a new AsyncShallowPostgresSaver instance from a connection string.\n\nParameters:\n\n  * **`conn_string`** (`str`) \u2013 \n\nThe Postgres connection info string.\n\n  * **`pipeline`** (`bool`, default: `False` ) \u2013 \n\nwhether to use AsyncPipeline\n\n\n\n\nReturns:\n\n  * **`AsyncShallowPostgresSaver`** ( `AsyncIterator[AsyncShallowPostgresSaver]` ) \u2013 \n\nA new AsyncShallowPostgresSaver instance.\n\n\n\n\n###  `` `setup() -> None` `async` \u00b6\n\nSet up the checkpoint database asynchronously.\n\nThis method creates the necessary tables in the Postgres database if they don't already exist and runs database migrations. It MUST be called directly by the user the first time checkpointer is used.\n\n###  `` `alist(config: Optional[RunnableConfig], *, filter: Optional[dict[str, Any]] = None, before: Optional[RunnableConfig] = None, limit: Optional[int] = None) -> AsyncIterator[CheckpointTuple]` `async` \u00b6\n\nList checkpoints from the database asynchronously.\n\nThis method retrieves a list of checkpoint tuples from the Postgres database based on the provided config. For ShallowPostgresSaver, this method returns a list with ONLY the most recent checkpoint.\n\n###  `` `aget_tuple(config: RunnableConfig) -> Optional[CheckpointTuple]` `async` \u00b6\n\nGet a checkpoint tuple from the database asynchronously.\n\nThis method retrieves a checkpoint tuple from the Postgres database based on the provided config (matching the thread ID in the config).\n\nParameters:\n\n  * **`config`** (`RunnableConfig`) \u2013 \n\nThe config to use for retrieving the checkpoint.\n\n\n\n\nReturns:\n\n  * `Optional[CheckpointTuple]` \u2013 \n\nOptional[CheckpointTuple]: The retrieved checkpoint tuple, or None if no matching checkpoint was found.\n\n\n\n\n###  `` `aput(config: RunnableConfig, checkpoint: Checkpoint, metadata: CheckpointMetadata, new_versions: ChannelVersions) -> RunnableConfig` `async` \u00b6\n\nSave a checkpoint to the database asynchronously.\n\nThis method saves a checkpoint to the Postgres database. The checkpoint is associated with the provided config. For AsyncShallowPostgresSaver, this method saves ONLY the most recent checkpoint and overwrites a previous checkpoint, if it exists.\n\nParameters:\n\n  * **`config`** (`RunnableConfig`) \u2013 \n\nThe config to associate with the checkpoint.\n\n  * **`checkpoint`** (`Checkpoint`) \u2013 \n\nThe checkpoint to save.\n\n  * **`metadata`** (`CheckpointMetadata`) \u2013 \n\nAdditional metadata to save with the checkpoint.\n\n  * **`new_versions`** (`ChannelVersions`) \u2013 \n\nNew channel versions as of this write.\n\n\n\n\nReturns:\n\n  * **`RunnableConfig`** ( `RunnableConfig` ) \u2013 \n\nUpdated configuration after storing the checkpoint.\n\n\n\n\n###  `` `aput_writes(config: RunnableConfig, writes: Sequence[tuple[str, Any]], task_id: str, task_path: str = '') -> None` `async` \u00b6\n\nStore intermediate writes linked to a checkpoint asynchronously.\n\nThis method saves intermediate writes associated with a checkpoint to the database.\n\nParameters:\n\n  * **`config`** (`RunnableConfig`) \u2013 \n\nConfiguration of the related checkpoint.\n\n  * **`writes`** (`Sequence[Tuple[str, Any]]`) \u2013 \n\nList of writes to store, each as (channel, value) pair.\n\n  * **`task_id`** (`str`) \u2013 \n\nIdentifier for the task creating the writes.\n\n\n\n\n###  `` `list(config: Optional[RunnableConfig], *, filter: Optional[dict[str, Any]] = None, before: Optional[RunnableConfig] = None, limit: Optional[int] = None) -> Iterator[CheckpointTuple]` \u00b6\n\nList checkpoints from the database.\n\nThis method retrieves a list of checkpoint tuples from the Postgres database based on the provided config. For ShallowPostgresSaver, this method returns a list with ONLY the most recent checkpoint.\n\n###  `` `get_tuple(config: RunnableConfig) -> Optional[CheckpointTuple]` \u00b6\n\nGet a checkpoint tuple from the database.\n\nThis method retrieves a checkpoint tuple from the Postgres database based on the provided config (matching the thread ID in the config).\n\nParameters:\n\n  * **`config`** (`RunnableConfig`) \u2013 \n\nThe config to use for retrieving the checkpoint.\n\n\n\n\nReturns:\n\n  * `Optional[CheckpointTuple]` \u2013 \n\nOptional[CheckpointTuple]: The retrieved checkpoint tuple, or None if no matching checkpoint was found.\n\n\n\n\n###  `` `put(config: RunnableConfig, checkpoint: Checkpoint, metadata: CheckpointMetadata, new_versions: ChannelVersions) -> RunnableConfig` \u00b6\n\nSave a checkpoint to the database.\n\nThis method saves a checkpoint to the Postgres database. The checkpoint is associated with the provided config. For AsyncShallowPostgresSaver, this method saves ONLY the most recent checkpoint and overwrites a previous checkpoint, if it exists.\n\nParameters:\n\n  * **`config`** (`RunnableConfig`) \u2013 \n\nThe config to associate with the checkpoint.\n\n  * **`checkpoint`** (`Checkpoint`) \u2013 \n\nThe checkpoint to save.\n\n  * **`metadata`** (`CheckpointMetadata`) \u2013 \n\nAdditional metadata to save with the checkpoint.\n\n  * **`new_versions`** (`ChannelVersions`) \u2013 \n\nNew channel versions as of this write.\n\n\n\n\nReturns:\n\n  * **`RunnableConfig`** ( `RunnableConfig` ) \u2013 \n\nUpdated configuration after storing the checkpoint.\n\n\n\n\n###  `` `put_writes(config: RunnableConfig, writes: Sequence[tuple[str, Any]], task_id: str, task_path: str = '') -> None` \u00b6\n\nStore intermediate writes linked to a checkpoint.\n\nThis method saves intermediate writes associated with a checkpoint to the database.\n\nParameters:\n\n  * **`config`** (`RunnableConfig`) \u2013 \n\nConfiguration of the related checkpoint.\n\n  * **`writes`** (`Sequence[Tuple[str, Any]]`) \u2013 \n\nList of writes to store, each as (channel, value) pair.\n\n  * **`task_id`** (`str`) \u2013 \n\nIdentifier for the task creating the writes.\n\n  * **`task_path`** (`str`, default: `''` ) \u2013 \n\nPath of the task creating the writes.\n\n\n\n\n##  `` `AsyncPostgresSaver` \u00b6\n\nBases: `BasePostgresSaver`\n\n###  `` `config_specs: list[ConfigurableFieldSpec]` `property` \u00b6\n\nDefine the configuration options for the checkpoint saver.\n\nReturns:\n\n  * `list[ConfigurableFieldSpec]` \u2013 \n\nlist[ConfigurableFieldSpec]: List of configuration field specs.\n\n\n\n\n###  `` `get(config: RunnableConfig) -> Optional[Checkpoint]` \u00b6\n\nFetch a checkpoint using the given configuration.\n\nParameters:\n\n  * **`config`** (`RunnableConfig`) \u2013 \n\nConfiguration specifying which checkpoint to retrieve.\n\n\n\n\nReturns:\n\n  * `Optional[Checkpoint]` \u2013 \n\nOptional[Checkpoint]: The requested checkpoint, or None if not found.\n\n\n\n\n###  `` `aget(config: RunnableConfig) -> Optional[Checkpoint]` `async` \u00b6\n\nAsynchronously fetch a checkpoint using the given configuration.\n\nParameters:\n\n  * **`config`** (`RunnableConfig`) \u2013 \n\nConfiguration specifying which checkpoint to retrieve.\n\n\n\n\nReturns:\n\n  * `Optional[Checkpoint]` \u2013 \n\nOptional[Checkpoint]: The requested checkpoint, or None if not found.\n\n\n\n\n###  `` `from_conn_string(conn_string: str, *, pipeline: bool = False, serde: Optional[SerializerProtocol] = None) -> AsyncIterator[AsyncPostgresSaver]` `async` `classmethod` \u00b6\n\nCreate a new AsyncPostgresSaver instance from a connection string.\n\nParameters:\n\n  * **`conn_string`** (`str`) \u2013 \n\nThe Postgres connection info string.\n\n  * **`pipeline`** (`bool`, default: `False` ) \u2013 \n\nwhether to use AsyncPipeline\n\n\n\n\nReturns:\n\n  * **`AsyncPostgresSaver`** ( `AsyncIterator[AsyncPostgresSaver]` ) \u2013 \n\nA new AsyncPostgresSaver instance.\n\n\n\n\n###  `` `setup() -> None` `async` \u00b6\n\nSet up the checkpoint database asynchronously.\n\nThis method creates the necessary tables in the Postgres database if they don't already exist and runs database migrations. It MUST be called directly by the user the first time checkpointer is used.\n\n###  `` `alist(config: Optional[RunnableConfig], *, filter: Optional[dict[str, Any]] = None, before: Optional[RunnableConfig] = None, limit: Optional[int] = None) -> AsyncIterator[CheckpointTuple]` `async` \u00b6\n\nList checkpoints from the database asynchronously.\n\nThis method retrieves a list of checkpoint tuples from the Postgres database based on the provided config. The checkpoints are ordered by checkpoint ID in descending order (newest first).\n\nParameters:\n\n  * **`config`** (`Optional[RunnableConfig]`) \u2013 \n\nBase configuration for filtering checkpoints.\n\n  * **`filter`** (`Optional[Dict[str, Any]]`, default: `None` ) \u2013 \n\nAdditional filtering criteria for metadata.\n\n  * **`before`** (`Optional[RunnableConfig]`, default: `None` ) \u2013 \n\nIf provided, only checkpoints before the specified checkpoint ID are returned. Defaults to None.\n\n  * **`limit`** (`Optional[int]`, default: `None` ) \u2013 \n\nMaximum number of checkpoints to return.\n\n\n\n\nYields:\n\n  * `AsyncIterator[CheckpointTuple]` \u2013 \n\nAsyncIterator[CheckpointTuple]: An asynchronous iterator of matching checkpoint tuples.\n\n\n\n\n###  `` `aget_tuple(config: RunnableConfig) -> Optional[CheckpointTuple]` `async` \u00b6\n\nGet a checkpoint tuple from the database asynchronously.\n\nThis method retrieves a checkpoint tuple from the Postgres database based on the provided config. If the config contains a \"checkpoint_id\" key, the checkpoint with the matching thread ID and \"checkpoint_id\" is retrieved. Otherwise, the latest checkpoint for the given thread ID is retrieved.\n\nParameters:\n\n  * **`config`** (`RunnableConfig`) \u2013 \n\nThe config to use for retrieving the checkpoint.\n\n\n\n\nReturns:\n\n  * `Optional[CheckpointTuple]` \u2013 \n\nOptional[CheckpointTuple]: The retrieved checkpoint tuple, or None if no matching checkpoint was found.\n\n\n\n\n###  `` `aput(config: RunnableConfig, checkpoint: Checkpoint, metadata: CheckpointMetadata, new_versions: ChannelVersions) -> RunnableConfig` `async` \u00b6\n\nSave a checkpoint to the database asynchronously.\n\nThis method saves a checkpoint to the Postgres database. The checkpoint is associated with the provided config and its parent config (if any).\n\nParameters:\n\n  * **`config`** (`RunnableConfig`) \u2013 \n\nThe config to associate with the checkpoint.\n\n  * **`checkpoint`** (`Checkpoint`) \u2013 \n\nThe checkpoint to save.\n\n  * **`metadata`** (`CheckpointMetadata`) \u2013 \n\nAdditional metadata to save with the checkpoint.\n\n  * **`new_versions`** (`ChannelVersions`) \u2013 \n\nNew channel versions as of this write.\n\n\n\n\nReturns:\n\n  * **`RunnableConfig`** ( `RunnableConfig` ) \u2013 \n\nUpdated configuration after storing the checkpoint.\n\n\n\n\n###  `` `aput_writes(config: RunnableConfig, writes: Sequence[tuple[str, Any]], task_id: str, task_path: str = '') -> None` `async` \u00b6\n\nStore intermediate writes linked to a checkpoint asynchronously.\n\nThis method saves intermediate writes associated with a checkpoint to the database.\n\nParameters:\n\n  * **`config`** (`RunnableConfig`) \u2013 \n\nConfiguration of the related checkpoint.\n\n  * **`writes`** (`Sequence[Tuple[str, Any]]`) \u2013 \n\nList of writes to store, each as (channel, value) pair.\n\n  * **`task_id`** (`str`) \u2013 \n\nIdentifier for the task creating the writes.\n\n\n\n\n###  `` `list(config: Optional[RunnableConfig], *, filter: Optional[dict[str, Any]] = None, before: Optional[RunnableConfig] = None, limit: Optional[int] = None) -> Iterator[CheckpointTuple]` \u00b6\n\nList checkpoints from the database.\n\nThis method retrieves a list of checkpoint tuples from the Postgres database based on the provided config. The checkpoints are ordered by checkpoint ID in descending order (newest first).\n\nParameters:\n\n  * **`config`** (`Optional[RunnableConfig]`) \u2013 \n\nBase configuration for filtering checkpoints.\n\n  * **`filter`** (`Optional[Dict[str, Any]]`, default: `None` ) \u2013 \n\nAdditional filtering criteria for metadata.\n\n  * **`before`** (`Optional[RunnableConfig]`, default: `None` ) \u2013 \n\nIf provided, only checkpoints before the specified checkpoint ID are returned. Defaults to None.\n\n  * **`limit`** (`Optional[int]`, default: `None` ) \u2013 \n\nMaximum number of checkpoints to return.\n\n\n\n\nYields:\n\n  * `CheckpointTuple` \u2013 \n\nIterator[CheckpointTuple]: An iterator of matching checkpoint tuples.\n\n\n\n\n###  `` `get_tuple(config: RunnableConfig) -> Optional[CheckpointTuple]` \u00b6\n\nGet a checkpoint tuple from the database.\n\nThis method retrieves a checkpoint tuple from the Postgres database based on the provided config. If the config contains a \"checkpoint_id\" key, the checkpoint with the matching thread ID and \"checkpoint_id\" is retrieved. Otherwise, the latest checkpoint for the given thread ID is retrieved.\n\nParameters:\n\n  * **`config`** (`RunnableConfig`) \u2013 \n\nThe config to use for retrieving the checkpoint.\n\n\n\n\nReturns:\n\n  * `Optional[CheckpointTuple]` \u2013 \n\nOptional[CheckpointTuple]: The retrieved checkpoint tuple, or None if no matching checkpoint was found.\n\n\n\n\n###  `` `put(config: RunnableConfig, checkpoint: Checkpoint, metadata: CheckpointMetadata, new_versions: ChannelVersions) -> RunnableConfig` \u00b6\n\nSave a checkpoint to the database.\n\nThis method saves a checkpoint to the Postgres database. The checkpoint is associated with the provided config and its parent config (if any).\n\nParameters:\n\n  * **`config`** (`RunnableConfig`) \u2013 \n\nThe config to associate with the checkpoint.\n\n  * **`checkpoint`** (`Checkpoint`) \u2013 \n\nThe checkpoint to save.\n\n  * **`metadata`** (`CheckpointMetadata`) \u2013 \n\nAdditional metadata to save with the checkpoint.\n\n  * **`new_versions`** (`ChannelVersions`) \u2013 \n\nNew channel versions as of this write.\n\n\n\n\nReturns:\n\n  * **`RunnableConfig`** ( `RunnableConfig` ) \u2013 \n\nUpdated configuration after storing the checkpoint.\n\n\n\n\n###  `` `put_writes(config: RunnableConfig, writes: Sequence[tuple[str, Any]], task_id: str, task_path: str = '') -> None` \u00b6\n\nStore intermediate writes linked to a checkpoint.\n\nThis method saves intermediate writes associated with a checkpoint to the database.\n\nParameters:\n\n  * **`config`** (`RunnableConfig`) \u2013 \n\nConfiguration of the related checkpoint.\n\n  * **`writes`** (`Sequence[Tuple[str, Any]]`) \u2013 \n\nList of writes to store, each as (channel, value) pair.\n\n  * **`task_id`** (`str`) \u2013 \n\nIdentifier for the task creating the writes.\n\n  * **`task_path`** (`str`, default: `''` ) \u2013 \n\nPath of the task creating the writes.\n\n\n\n\n## Comments\n",
    "metadata": {
        "url": "https://langchain-ai.github.io/langgraph/reference/checkpoints/#langgraph.checkpoint.memory.MemorySaver",
        "title": "Checkpointing",
        "description": "Build language agents as graphs",
        "keywords": "No keywords"
    }
}