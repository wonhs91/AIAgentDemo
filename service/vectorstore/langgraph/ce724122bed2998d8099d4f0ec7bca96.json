{
    "page_content": "# Prebuilt\u00b6\n\n##  `` `create_react_agent(model: Union[str, LanguageModelLike], tools: Union[ToolExecutor, Sequence[BaseTool], ToolNode], *, state_schema: Optional[StateSchemaType] = None, prompt: Optional[Prompt] = None, response_format: Optional[Union[StructuredResponseSchema, tuple[str, StructuredResponseSchema]]] = None, checkpointer: Optional[Checkpointer] = None, store: Optional[BaseStore] = None, interrupt_before: Optional[list[str]] = None, interrupt_after: Optional[list[str]] = None, debug: bool = False, version: Literal['v1', 'v2'] = 'v1', name: Optional[str] = None) -> CompiledGraph` \u00b6\n\nCreates a graph that works with a chat model that utilizes tool calling.\n\nParameters:\n\n  * **`model`** (`Union[str, LanguageModelLike]`) \u2013 \n\nThe `LangChain` chat model that supports tool calling.\n\n  * **`tools`** (`Union[ToolExecutor, Sequence[BaseTool], ToolNode]`) \u2013 \n\nA list of tools, a ToolExecutor, or a ToolNode instance. If an empty list is provided, the agent will consist of a single LLM node without tool calling.\n\n  * **`state_schema`** (`Optional[StateSchemaType]`, default: `None` ) \u2013 \n\nAn optional state schema that defines graph state. Must have `messages` and `is_last_step` keys. Defaults to `AgentState` that defines those two keys.\n\n  * **`prompt`** (`Optional[Prompt]`, default: `None` ) \u2013 \n\nAn optional prompt for the LLM. Can take a few different forms:\n\n    * str: This is converted to a SystemMessage and added to the beginning of the list of messages in state[\"messages\"].\n    * SystemMessage: this is added to the beginning of the list of messages in state[\"messages\"].\n    * Callable: This function should take in full graph state and the output is then passed to the language model.\n    * Runnable: This runnable should take in full graph state and the output is then passed to the language model.\n\nNote\n\nPrior to `v0.2.68`, the prompt was set using `state_modifier` / `messages_modifier` parameters.\n\n  * **`response_format`** (`Optional[Union[StructuredResponseSchema, tuple[str, StructuredResponseSchema]]]`, default: `None` ) \u2013 \n\nAn optional schema for the final agent output.\n\nIf provided, output will be formatted to match the given schema and returned in the 'structured_response' state key. If not provided, `structured_response` will not be present in the output state. Can be passed in as:\n[code]     - an OpenAI function/tool schema,\n    - a JSON Schema,\n    - a TypedDict class,\n    - or a Pydantic class.\n    - a tuple (prompt, schema), where schema is one of the above.\n        The prompt will be used together with the model that is being used to generate the structured response.\n    \n[/code]\n\nImportant\n\n`response_format` requires the model to support `.with_structured_output`\n\nNote\n\nThe graph will make a separate call to the LLM to generate the structured response after the agent loop is finished. This is not the only strategy to get structured responses, see more options in this guide.\n\n  * **`checkpointer`** (`Optional[Checkpointer]`, default: `None` ) \u2013 \n\nAn optional checkpoint saver object. This is used for persisting the state of the graph (e.g., as chat memory) for a single thread (e.g., a single conversation).\n\n  * **`store`** (`Optional[BaseStore]`, default: `None` ) \u2013 \n\nAn optional store object. This is used for persisting data across multiple threads (e.g., multiple conversations / users).\n\n  * **`interrupt_before`** (`Optional[list[str]]`, default: `None` ) \u2013 \n\nAn optional list of node names to interrupt before. Should be one of the following: \"agent\", \"tools\". This is useful if you want to add a user confirmation or other interrupt before taking an action.\n\n  * **`interrupt_after`** (`Optional[list[str]]`, default: `None` ) \u2013 \n\nAn optional list of node names to interrupt after. Should be one of the following: \"agent\", \"tools\". This is useful if you want to return directly or run additional processing on an output.\n\n  * **`debug`** (`bool`, default: `False` ) \u2013 \n\nA flag indicating whether to enable debug mode.\n\n  * **`version`** (`Literal['v1', 'v2']`, default: `'v1'` ) \u2013 \n\nDetermines the version of the graph to create. Can be one of:\n\n    * `\"v1\"`: The tool node processes a single message. All tool calls in the message are executed in parallel within the tool node.\n    * `\"v2\"`: The tool node processes a tool call. Tool calls are distributed across multiple instances of the tool node using the Send API.\n\n  * **`name`** (`Optional[str]`, default: `None` ) \u2013 \n\nAn optional name for the CompiledStateGraph. This name will be automatically used when adding ReAct agent graph to another graph as a subgraph node - particularly useful for building multi-agent systems.\n\n\n\n\nReturns:\n\n  * `CompiledGraph` \u2013 \n\nA compiled LangChain runnable that can be used for chat interactions.\n\n\n\n\nThe resulting graph looks like this:\n[code] \n    stateDiagram-v2\n        [*] --> Start\n        Start --> Agent\n        Agent --> Tools : continue\n        Tools --> Agent\n        Agent --> End : end\n        End --> [*]\n    \n        classDef startClass fill:#ffdfba;\n        classDef endClass fill:#baffc9;\n        classDef otherClass fill:#fad7de;\n    \n        class Start startClass\n        class End endClass\n        class Agent,Tools otherClass\n[/code]\n\nThe \"agent\" node calls the language model with the messages list (after applying the messages modifier). If the resulting AIMessage contains `tool_calls`, the graph will then call the \"tools\". The \"tools\" node executes the tools (1 tool per `tool_call`) and adds the responses to the messages list as `ToolMessage` objects. The agent node then calls the language model again. The process repeats until no more `tool_calls` are present in the response. The agent then returns the full list of messages as a dictionary containing the key \"messages\".\n[code] \n        sequenceDiagram\n            participant U as User\n            participant A as Agent (LLM)\n            participant T as Tools\n            U->>A: Initial input\n            Note over A: Messages modifier + LLM\n            loop while tool_calls present\n                A->>T: Execute tools\n                T-->>A: ToolMessage for each tool_calls\n            end\n            A->>U: Return final state\n[/code]\n\nExamples:\n\nUse with a simple tool:\n[code] \n    >>> from datetime import datetime\n    >>> from langchain_openai import ChatOpenAI\n    >>> from langgraph.prebuilt import create_react_agent\n    \n    \n    ... def check_weather(location: str, at_time: datetime | None = None) -> str:\n    ...     '''Return the weather forecast for the specified location.'''\n    ...     return f\"It's always sunny in {location}\"\n    >>>\n    >>> tools = [check_weather]\n    >>> model = ChatOpenAI(model=\"gpt-4o\")\n    >>> graph = create_react_agent(model, tools=tools)\n    >>> inputs = {\"messages\": [(\"user\", \"what is the weather in sf\")]}\n    >>> for s in graph.stream(inputs, stream_mode=\"values\"):\n    ...     message = s[\"messages\"][-1]\n    ...     if isinstance(message, tuple):\n    ...         print(message)\n    ...     else:\n    ...         message.pretty_print()\n    ('user', 'what is the weather in sf')\n    ================================== Ai Message ==================================\n    Tool Calls:\n    check_weather (call_LUzFvKJRuaWQPeXvBOzwhQOu)\n    Call ID: call_LUzFvKJRuaWQPeXvBOzwhQOu\n    Args:\n        location: San Francisco\n    ================================= Tool Message =================================\n    Name: check_weather\n    It's always sunny in San Francisco\n    ================================== Ai Message ==================================\n    The weather in San Francisco is sunny.\n    \n[/code]\n\nAdd a system prompt for the LLM:\n[code] \n    >>> system_prompt = \"You are a helpful bot named Fred.\"\n    >>> graph = create_react_agent(model, tools, prompt=system_prompt)\n    >>> inputs = {\"messages\": [(\"user\", \"What's your name? And what's the weather in SF?\")]}\n    >>> for s in graph.stream(inputs, stream_mode=\"values\"):\n    ...     message = s[\"messages\"][-1]\n    ...     if isinstance(message, tuple):\n    ...         print(message)\n    ...     else:\n    ...         message.pretty_print()\n    ('user', \"What's your name? And what's the weather in SF?\")\n    ================================== Ai Message ==================================\n    Hi, my name is Fred. Let me check the weather in San Francisco for you.\n    Tool Calls:\n    check_weather (call_lqhj4O0hXYkW9eknB4S41EXk)\n    Call ID: call_lqhj4O0hXYkW9eknB4S41EXk\n    Args:\n        location: San Francisco\n    ================================= Tool Message =================================\n    Name: check_weather\n    It's always sunny in San Francisco\n    ================================== Ai Message ==================================\n    The weather in San Francisco is currently sunny. If you need any more details or have other questions, feel free to ask!\n    \n[/code]\n\nAdd a more complex prompt for the LLM:\n[code] \n    >>> from langchain_core.prompts import ChatPromptTemplate\n    >>> prompt = ChatPromptTemplate.from_messages([\n    ...     (\"system\", \"You are a helpful bot named Fred.\"),\n    ...     (\"placeholder\", \"{messages}\"),\n    ...     (\"user\", \"Remember, always be polite!\"),\n    ... ])\n    >>>\n    >>> graph = create_react_agent(model, tools, prompt=prompt)\n    >>> inputs = {\"messages\": [(\"user\", \"What's your name? And what's the weather in SF?\")]}\n    >>> for s in graph.stream(inputs, stream_mode=\"values\"):\n    ...     message = s[\"messages\"][-1]\n    ...     if isinstance(message, tuple):\n    ...         print(message)\n    ...     else:\n    ...         message.pretty_print()\n    \n[/code]\n\nAdd complex prompt with custom graph state:\n[code] \n    >>> from typing_extensions import TypedDict\n    >>>\n    >>> from langgraph.managed import IsLastStep\n    >>> prompt = ChatPromptTemplate.from_messages(\n    ...     [\n    ...         (\"system\", \"Today is {today}\"),\n    ...         (\"placeholder\", \"{messages}\"),\n    ...     ]\n    ... )\n    >>>\n    >>> class CustomState(TypedDict):\n    ...     today: str\n    ...     messages: Annotated[list[BaseMessage], add_messages]\n    ...     is_last_step: IsLastStep\n    >>>\n    >>> graph = create_react_agent(model, tools, state_schema=CustomState, prompt=prompt)\n    >>> inputs = {\"messages\": [(\"user\", \"What's today's date? And what's the weather in SF?\")], \"today\": \"July 16, 2004\"}\n    >>> for s in graph.stream(inputs, stream_mode=\"values\"):\n    ...     message = s[\"messages\"][-1]\n    ...     if isinstance(message, tuple):\n    ...         print(message)\n    ...     else:\n    ...         message.pretty_print()\n    \n[/code]\n\nAdd thread-level \"chat memory\" to the graph:\n[code] \n    >>> from langgraph.checkpoint.memory import MemorySaver\n    >>> graph = create_react_agent(model, tools, checkpointer=MemorySaver())\n    >>> config = {\"configurable\": {\"thread_id\": \"thread-1\"}}\n    >>> def print_stream(graph, inputs, config):\n    ...     for s in graph.stream(inputs, config, stream_mode=\"values\"):\n    ...         message = s[\"messages\"][-1]\n    ...         if isinstance(message, tuple):\n    ...             print(message)\n    ...         else:\n    ...             message.pretty_print()\n    >>> inputs = {\"messages\": [(\"user\", \"What's the weather in SF?\")]}\n    >>> print_stream(graph, inputs, config)\n    >>> inputs2 = {\"messages\": [(\"user\", \"Cool, so then should i go biking today?\")]}\n    >>> print_stream(graph, inputs2, config)\n    ('user', \"What's the weather in SF?\")\n    ================================== Ai Message ==================================\n    Tool Calls:\n    check_weather (call_ChndaktJxpr6EMPEB5JfOFYc)\n    Call ID: call_ChndaktJxpr6EMPEB5JfOFYc\n    Args:\n        location: San Francisco\n    ================================= Tool Message =================================\n    Name: check_weather\n    It's always sunny in San Francisco\n    ================================== Ai Message ==================================\n    The weather in San Francisco is sunny. Enjoy your day!\n    ================================ Human Message =================================\n    Cool, so then should i go biking today?\n    ================================== Ai Message ==================================\n    Since the weather in San Francisco is sunny, it sounds like a great day for biking! Enjoy your ride!\n    \n[/code]\n\nAdd an interrupt to let the user confirm before taking an action:\n[code] \n    >>> graph = create_react_agent(\n    ...     model, tools, interrupt_before=[\"tools\"], checkpointer=MemorySaver()\n    >>> )\n    >>> config = {\"configurable\": {\"thread_id\": \"thread-1\"}}\n    \n    >>> inputs = {\"messages\": [(\"user\", \"What's the weather in SF?\")]}\n    >>> print_stream(graph, inputs, config)\n    >>> snapshot = graph.get_state(config)\n    >>> print(\"Next step: \", snapshot.next)\n    >>> print_stream(graph, None, config)\n    \n[/code]\n\nAdd cross-thread memory to the graph:\n[code] \n    >>> from langgraph.prebuilt import InjectedStore\n    >>> from langgraph.store.base import BaseStore\n    \n    >>> def save_memory(memory: str, *, config: RunnableConfig, store: Annotated[BaseStore, InjectedStore()]) -> str:\n    ...     '''Save the given memory for the current user.'''\n    ...     # This is a **tool** the model can use to save memories to storage\n    ...     user_id = config.get(\"configurable\", {}).get(\"user_id\")\n    ...     namespace = (\"memories\", user_id)\n    ...     store.put(namespace, f\"memory_{len(store.search(namespace))}\", {\"data\": memory})\n    ...     return f\"Saved memory: {memory}\"\n    \n    >>> def prepare_model_inputs(state: AgentState, config: RunnableConfig, store: BaseStore):\n    ...     # Retrieve user memories and add them to the system message\n    ...     # This function is called **every time** the model is prompted. It converts the state to a prompt\n    ...     user_id = config.get(\"configurable\", {}).get(\"user_id\")\n    ...     namespace = (\"memories\", user_id)\n    ...     memories = [m.value[\"data\"] for m in store.search(namespace)]\n    ...     system_msg = f\"User memories: {', '.join(memories)}\"\n    ...     return [{\"role\": \"system\", \"content\": system_msg)] + state[\"messages\"]\n    \n    >>> from langgraph.checkpoint.memory import MemorySaver\n    >>> from langgraph.store.memory import InMemoryStore\n    >>> store = InMemoryStore()\n    >>> graph = create_react_agent(model, [save_memory], prompt=prepare_model_inputs, store=store, checkpointer=MemorySaver())\n    >>> config = {\"configurable\": {\"thread_id\": \"thread-1\", \"user_id\": \"1\"}}\n    \n    >>> inputs = {\"messages\": [(\"user\", \"Hey I'm Will, how's it going?\")]}\n    >>> print_stream(graph, inputs, config)\n    ('user', \"Hey I'm Will, how's it going?\")\n    ================================== Ai Message ==================================\n    Hello Will! It's nice to meet you. I'm doing well, thank you for asking. How are you doing today?\n    \n    >>> inputs2 = {\"messages\": [(\"user\", \"I like to bike\")]}\n    >>> print_stream(graph, inputs2, config)\n    ================================ Human Message =================================\n    I like to bike\n    ================================== Ai Message ==================================\n    That's great to hear, Will! Biking is an excellent hobby and form of exercise. It's a fun way to stay active and explore your surroundings. Do you have any favorite biking routes or trails you enjoy? Or perhaps you're into a specific type of biking, like mountain biking or road cycling?\n    \n    >>> config = {\"configurable\": {\"thread_id\": \"thread-2\", \"user_id\": \"1\"}}\n    >>> inputs3 = {\"messages\": [(\"user\", \"Hi there! Remember me?\")]}\n    >>> print_stream(graph, inputs3, config)\n    ================================ Human Message =================================\n    Hi there! Remember me?\n    ================================== Ai Message ==================================\n    User memories:\n    Hello! Of course, I remember you, Will! You mentioned earlier that you like to bike. It's great to hear from you again. How have you been? Have you been on any interesting bike rides lately?\n    \n[/code]\n\nAdd a timeout for a given step:\n[code] \n    >>> import time\n    ... def check_weather(location: str, at_time: datetime | None = None) -> float:\n    ...     '''Return the weather forecast for the specified location.'''\n    ...     time.sleep(2)\n    ...     return f\"It's always sunny in {location}\"\n    >>>\n    >>> tools = [check_weather]\n    >>> graph = create_react_agent(model, tools)\n    >>> graph.step_timeout = 1 # Seconds\n    >>> for s in graph.stream({\"messages\": [(\"user\", \"what is the weather in sf\")]}):\n    ...     print(s)\n    TimeoutError: Timed out at step 2\n    \n[/code]\n\n##  `` `ToolNode` \u00b6\n\nBases: `RunnableCallable`\n\nA node that runs the tools called in the last AIMessage.\n\nIt can be used either in StateGraph with a \"messages\" state key (or a custom key passed via ToolNode's 'messages_key'). If multiple tool calls are requested, they will be run in parallel. The output will be a list of ToolMessages, one for each tool call.\n\nTool calls can also be passed directly as a list of `ToolCall` dicts.\n\nParameters:\n\n  * **`tools`** (`Sequence[Union[BaseTool, Callable]]`) \u2013 \n\nA sequence of tools that can be invoked by the ToolNode.\n\n  * **`name`** (`str`, default: `'tools'` ) \u2013 \n\nThe name of the ToolNode in the graph. Defaults to \"tools\".\n\n  * **`tags`** (`Optional[list[str]]`, default: `None` ) \u2013 \n\nOptional tags to associate with the node. Defaults to None.\n\n  * **`handle_tool_errors`** (`Union[bool, str, Callable[..., str], tuple[type[Exception], ...]]`, default: `True` ) \u2013 \n\nHow to handle tool errors raised by tools inside the node. Defaults to True. Must be one of the following:\n\n    * True: all errors will be caught and a ToolMessage with a default error message (TOOL_CALL_ERROR_TEMPLATE) will be returned.\n    * str: all errors will be caught and a ToolMessage with the string value of 'handle_tool_errors' will be returned.\n    * tuple[type[Exception], ...]: exceptions in the tuple will be caught and a ToolMessage with a default error message (TOOL_CALL_ERROR_TEMPLATE) will be returned.\n    * Callable[..., str]: exceptions from the signature of the callable will be caught and a ToolMessage with the string value of the result of the 'handle_tool_errors' callable will be returned.\n    * False: none of the errors raised by the tools will be caught\n\n  * **`messages_key`** (`str`, default: `'messages'` ) \u2013 \n\nThe state key in the input that contains the list of messages. The same key will be used for the output from the ToolNode. Defaults to \"messages\".\n\n\n\n\nThe `ToolNode` is roughly analogous to:\n[code] \n    tools_by_name = {tool.name: tool for tool in tools}\n    def tool_node(state: dict):\n        result = []\n        for tool_call in state[\"messages\"][-1].tool_calls:\n            tool = tools_by_name[tool_call[\"name\"]]\n            observation = tool.invoke(tool_call[\"args\"])\n            result.append(ToolMessage(content=observation, tool_call_id=tool_call[\"id\"]))\n        return {\"messages\": result}\n    \n[/code]\n\nTool calls can also be passed directly to a ToolNode. This can be useful when using the Send API, e.g., in a conditional edge:\n[code] \n    def example_conditional_edge(state: dict) -> List[Send]:\n        tool_calls = state[\"messages\"][-1].tool_calls\n        # If tools rely on state or store variables (whose values are not generated\n        # directly by a model), you can inject them into the tool calls.\n        tool_calls = [\n            tool_node.inject_tool_args(call, state, store)\n            for call in last_message.tool_calls\n        ]\n        return [Send(\"tools\", [tool_call]) for tool_call in tool_calls]\n    \n[/code]\n\nImportant\n\n  * The input state can be one of the following:\n    * A dict with a messages key containing a list of messages.\n    * A list of messages.\n    * A list of tool calls.\n  * If operating on a message list, the last message must be an `AIMessage` with `tool_calls` populated.\n\n\n\n###  `` `inject_tool_args(tool_call: ToolCall, input: Union[list[AnyMessage], dict[str, Any], BaseModel], store: Optional[BaseStore]) -> ToolCall` \u00b6\n\nInjects the state and store into the tool call.\n\nTool arguments with types annotated as `InjectedState` and `InjectedStore` are ignored in tool schemas for generation purposes. This method injects them into tool calls for tool invocation.\n\nParameters:\n\n  * **`tool_call`** (`ToolCall`) \u2013 \n\nThe tool call to inject state and store into.\n\n  * **`input`** (`Union[list[AnyMessage], dict[str, Any], BaseModel]`) \u2013 \n\nThe input state to inject.\n\n  * **`store`** (`Optional[BaseStore]`) \u2013 \n\nThe store to inject.\n\n\n\n\nReturns:\n\n  * **`ToolCall`** ( `ToolCall` ) \u2013 \n\nThe tool call with injected state and store.\n\n\n\n\n##  `` `InjectedState` \u00b6\n\nBases: `InjectedToolArg`\n\nAnnotation for a Tool arg that is meant to be populated with the graph state.\n\nAny Tool argument annotated with InjectedState will be hidden from a tool-calling model, so that the model doesn't attempt to generate the argument. If using ToolNode, the appropriate graph state field will be automatically injected into the model-generated tool args.\n\nParameters:\n\n  * **`field`** (`Optional[str]`, default: `None` ) \u2013 \n\nThe key from state to insert. If None, the entire state is expected to be passed in.\n\n\nExample\n[code] \n    from typing import List\n    from typing_extensions import Annotated, TypedDict\n    \n    from langchain_core.messages import BaseMessage, AIMessage\n    from langchain_core.tools import tool\n    \n    from langgraph.prebuilt import InjectedState, ToolNode\n    \n    \n    class AgentState(TypedDict):\n        messages: List[BaseMessage]\n        foo: str\n    \n    @tool\n    def state_tool(x: int, state: Annotated[dict, InjectedState]) -> str:\n        '''Do something with state.'''\n        if len(state[\"messages\"]) > 2:\n            return state[\"foo\"] + str(x)\n        else:\n            return \"not enough messages\"\n    \n    @tool\n    def foo_tool(x: int, foo: Annotated[str, InjectedState(\"foo\")]) -> str:\n        '''Do something else with state.'''\n        return foo + str(x + 1)\n    \n    node = ToolNode([state_tool, foo_tool])\n    \n    tool_call1 = {\"name\": \"state_tool\", \"args\": {\"x\": 1}, \"id\": \"1\", \"type\": \"tool_call\"}\n    tool_call2 = {\"name\": \"foo_tool\", \"args\": {\"x\": 1}, \"id\": \"2\", \"type\": \"tool_call\"}\n    state = {\n        \"messages\": [AIMessage(\"\", tool_calls=[tool_call1, tool_call2])],\n        \"foo\": \"bar\",\n    }\n    node.invoke(state)\n    \n[/code]\n[code] \n    [\n        ToolMessage(content='not enough messages', name='state_tool', tool_call_id='1'),\n        ToolMessage(content='bar2', name='foo_tool', tool_call_id='2')\n    ]\n    \n[/code]\n\n##  `` `InjectedStore` \u00b6\n\nBases: `InjectedToolArg`\n\nAnnotation for a Tool arg that is meant to be populated with LangGraph store.\n\nAny Tool argument annotated with InjectedStore will be hidden from a tool-calling model, so that the model doesn't attempt to generate the argument. If using ToolNode, the appropriate store field will be automatically injected into the model-generated tool args. Note: if a graph is compiled with a store object, the store will be automatically propagated to the tools with InjectedStore args when using ToolNode.\n\nWarning\n\n`InjectedStore` annotation requires `langchain-core >= 0.3.8`\n\nExample\n[code] \n    from typing import Any\n    from typing_extensions import Annotated\n    \n    from langchain_core.messages import AIMessage\n    from langchain_core.tools import tool\n    \n    from langgraph.store.memory import InMemoryStore\n    from langgraph.prebuilt import InjectedStore, ToolNode\n    \n    store = InMemoryStore()\n    store.put((\"values\",), \"foo\", {\"bar\": 2})\n    \n    @tool\n    def store_tool(x: int, my_store: Annotated[Any, InjectedStore()]) -> str:\n        '''Do something with store.'''\n        stored_value = my_store.get((\"values\",), \"foo\").value[\"bar\"]\n        return stored_value + x\n    \n    node = ToolNode([store_tool])\n    \n    tool_call = {\"name\": \"store_tool\", \"args\": {\"x\": 1}, \"id\": \"1\", \"type\": \"tool_call\"}\n    state = {\n        \"messages\": [AIMessage(\"\", tool_calls=[tool_call])],\n    }\n    \n    node.invoke(state, store=store)\n    \n[/code]\n[code] \n    {\n        \"messages\": [\n            ToolMessage(content='3', name='store_tool', tool_call_id='1'),\n        ]\n    }\n    \n[/code]\n\n##  `` `tools_condition(state: Union[list[AnyMessage], dict[str, Any], BaseModel], messages_key: str = 'messages') -> Literal['tools', '__end__']` \u00b6\n\nUse in the conditional_edge to route to the ToolNode if the last message\n\nhas tool calls. Otherwise, route to the end.\n\nParameters:\n\n  * **`state`** (`Union[list[AnyMessage], dict[str, Any], BaseModel]`) \u2013 \n\nThe state to check for tool calls. Must have a list of messages (MessageGraph) or have the \"messages\" key (StateGraph).\n\n\n\n\nReturns:\n\n  * `Literal['tools', '__end__']` \u2013 \n\nThe next node to route to.\n\n\n\n\nExamples:\n\nCreate a custom ReAct-style agent with tools.\n[code] \n    >>> from langchain_anthropic import ChatAnthropic\n    >>> from langchain_core.tools import tool\n    ...\n    >>> from langgraph.graph import StateGraph\n    >>> from langgraph.prebuilt import ToolNode, tools_condition\n    >>> from langgraph.graph.message import add_messages\n    ...\n    >>> from typing import Annotated\n    >>> from typing_extensions import TypedDict\n    ...\n    >>> @tool\n    >>> def divide(a: float, b: float) -> int:\n    ...     \"\"\"Return a / b.\"\"\"\n    ...     return a / b\n    ...\n    >>> llm = ChatAnthropic(model=\"claude-3-haiku-20240307\")\n    >>> tools = [divide]\n    ...\n    >>> class State(TypedDict):\n    ...     messages: Annotated[list, add_messages]\n    >>>\n    >>> graph_builder = StateGraph(State)\n    >>> graph_builder.add_node(\"tools\", ToolNode(tools))\n    >>> graph_builder.add_node(\"chatbot\", lambda state: {\"messages\":llm.bind_tools(tools).invoke(state['messages'])})\n    >>> graph_builder.add_edge(\"tools\", \"chatbot\")\n    >>> graph_builder.add_conditional_edges(\n    ...     \"chatbot\", tools_condition\n    ... )\n    >>> graph_builder.set_entry_point(\"chatbot\")\n    >>> graph = graph_builder.compile()\n    >>> graph.invoke({\"messages\": {\"role\": \"user\", \"content\": \"What's 329993 divided by 13662?\"}})\n    \n[/code]\n\nThis module provides a ValidationNode class that can be used to validate tool calls in a langchain graph. It applies a pydantic schema to tool_calls in the models' outputs, and returns a ToolMessage with the validated content. If the schema is not valid, it returns a ToolMessage with the error message. The ValidationNode can be used in a StateGraph with a \"messages\" key or in a MessageGraph. If multiple tool calls are requested, they will be run in parallel.\n\n##  `` `ValidationNode` \u00b6\n\nBases: `RunnableCallable`\n\nA node that validates all tools requests from the last AIMessage.\n\nIt can be used either in StateGraph with a \"messages\" key or in MessageGraph.\n\nNote\n\nThis node does not actually **run** the tools, it only validates the tool calls, which is useful for extraction and other use cases where you need to generate structured output that conforms to a complex schema without losing the original messages and tool IDs (for use in multi-turn conversations).\n\nParameters:\n\n  * **`schemas`** (`Sequence[Union[BaseTool, Type[BaseModel], Callable]]`) \u2013 \n\nA list of schemas to validate the tool calls with. These can be any of the following: \\- A pydantic BaseModel class \\- A BaseTool instance (the args_schema will be used) \\- A function (a schema will be created from the function signature)\n\n  * **`format_error`** (`Optional[Callable[[BaseException, ToolCall, Type[BaseModel]], str]]`, default: `None` ) \u2013 \n\nA function that takes an exception, a ToolCall, and a schema and returns a formatted error string. By default, it returns the exception repr and a message to respond after fixing validation errors.\n\n  * **`name`** (`str`, default: `'validation'` ) \u2013 \n\nThe name of the node.\n\n  * **`tags`** (`Optional[list[str]]`, default: `None` ) \u2013 \n\nA list of tags to add to the node.\n\n\n\n\nReturns:\n\n  * `Union[Dict[str, List[ToolMessage]], Sequence[ToolMessage]]` \u2013 \n\nA list of ToolMessages with the validated content or error messages.\n\n\n\n\nExamples:\n\nExample usage for re-prompting the model to generate a valid response:\n[code] \n    >>> from typing import Literal, Annotated\n    >>> from typing_extensions import TypedDict\n    ...\n    >>> from langchain_anthropic import ChatAnthropic\n    >>> from pydantic import BaseModel, validator\n    ...\n    >>> from langgraph.graph import END, START, StateGraph\n    >>> from langgraph.prebuilt import ValidationNode\n    >>> from langgraph.graph.message import add_messages\n    ...\n    ...\n    >>> class SelectNumber(BaseModel):\n    ...     a: int\n    ...\n    ...     @validator(\"a\")\n    ...     def a_must_be_meaningful(cls, v):\n    ...         if v != 37:\n    ...             raise ValueError(\"Only 37 is allowed\")\n    ...         return v\n    ...\n    ...\n    >>> class State(TypedDict):\n    ...     messages: Annotated[list, add_messages]\n    ...\n    >>> builder = StateGraph(State)\n    >>> llm = ChatAnthropic(model=\"claude-3-haiku-20240307\").bind_tools([SelectNumber])\n    >>> builder.add_node(\"model\", llm)\n    >>> builder.add_node(\"validation\", ValidationNode([SelectNumber]))\n    >>> builder.add_edge(START, \"model\")\n    ...\n    ...\n    >>> def should_validate(state: list) -> Literal[\"validation\", \"__end__\"]:\n    ...     if state[-1].tool_calls:\n    ...         return \"validation\"\n    ...     return END\n    ...\n    ...\n    >>> builder.add_conditional_edges(\"model\", should_validate)\n    ...\n    ...\n    >>> def should_reprompt(state: list) -> Literal[\"model\", \"__end__\"]:\n    ...     for msg in state[::-1]:\n    ...         # None of the tool calls were errors\n    ...         if msg.type == \"ai\":\n    ...             return END\n    ...         if msg.additional_kwargs.get(\"is_error\"):\n    ...             return \"model\"\n    ...     return END\n    ...\n    ...\n    >>> builder.add_conditional_edges(\"validation\", should_reprompt)\n    ...\n    ...\n    >>> graph = builder.compile()\n    >>> res = graph.invoke((\"user\", \"Select a number, any number\"))\n    >>> # Show the retry logic\n    >>> for msg in res:\n    ...     msg.pretty_print()\n    ================================ Human Message =================================\n    Select a number, any number\n    ================================== Ai Message ==================================\n    [{'id': 'toolu_01JSjT9Pq8hGmTgmMPc6KnvM', 'input': {'a': 42}, 'name': 'SelectNumber', 'type': 'tool_use'}]\n    Tool Calls:\n    SelectNumber (toolu_01JSjT9Pq8hGmTgmMPc6KnvM)\n    Call ID: toolu_01JSjT9Pq8hGmTgmMPc6KnvM\n    Args:\n        a: 42\n    ================================= Tool Message =================================\n    Name: SelectNumber\n    ValidationError(model='SelectNumber', errors=[{'loc': ('a',), 'msg': 'Only 37 is allowed', 'type': 'value_error'}])\n    Respond after fixing all validation errors.\n    ================================== Ai Message ==================================\n    [{'id': 'toolu_01PkxSVxNxc5wqwCPW1FiSmV', 'input': {'a': 37}, 'name': 'SelectNumber', 'type': 'tool_use'}]\n    Tool Calls:\n    SelectNumber (toolu_01PkxSVxNxc5wqwCPW1FiSmV)\n    Call ID: toolu_01PkxSVxNxc5wqwCPW1FiSmV\n    Args:\n        a: 37\n    ================================= Tool Message =================================\n    Name: SelectNumber\n    {\"a\": 37}\n    \n[/code]\n\n## Comments\n",
    "metadata": {
        "url": "https://langchain-ai.github.io/langgraph/reference/prebuilt/#langgraph.prebuilt.tool_node.tools_condition",
        "title": "Prebuilt components",
        "description": "Build language agents as graphs",
        "keywords": "No keywords"
    }
}